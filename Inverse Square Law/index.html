<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Inverse Square Law</title>

    <!-- KaTeX for LaTeX rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" xintegrity="sha384-sCutvgpopvms1PSRPY+ax+sUpl1jsmm4w6+ERsYSJOiS2BZAoAx1+t1JdGjV3b85" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" xintegrity="sha384-hIoBPJpTadox55GCNM+PBOZpTmxH+SSt+HkexsB4rUIeGajGAXXfEaY9sm2RXP5L" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" xintegrity="sha384-43gviWU0YVjaDtb/Gf1I3Oths0VyDsAlpOvx8v2iIAMoZgKcrypMe7Au17VebouV" crossorigin="anonymous"></script>

    <!-- Chart.js for graphing -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        :root {
            --claret: #800000;
            --light-claret: #B03A2E;
            --darker-claret: #8a2e24;
            --amber: #FFBF00;
            --blush-pink: #F1D4D4;
            --pale-violet: #E6E6FA;
            --white: #FFFFFF;
            --black: #000000;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: var(--pale-violet);
            margin: 0;
            padding: 20px;
        }

        /* Header Styling */
        .header-container {
            background-color: var(--claret);
            border-radius: 10px;
            border: 2px solid var(--black);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            text-align: center;
            padding: 20px;
            margin-bottom: 20px;
            color: var(--white);
        }

        .header-title {
            color: var(--amber);
            font-weight: bold;
            font-size: 2em;
            margin: 0;
            font-family: Arial, sans-serif; /* Matched from Refractive Index Sim */
        }

        .header-subtitle {
            color: var(--blush-pink);
            font-size: 1.5em;
            margin: 0; /* Adjusted margin */
            font-family: Arial, sans-serif; /* Matched from Refractive Index Sim */
            font-weight: normal; /* Matched from Refractive Index Sim */
        }

        /* Layout Styling */
        .main-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            align-items: start;
        }

        @media (max-width: 1000px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Card Styling */
        .card {
            background-color: var(--white);
            border-radius: 10px;
            border: 2px solid var(--black);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            padding: 20px;
        }

        .card h3 {
            margin-top: 0;
            border-bottom: 2px solid var(--pale-violet);
            padding-bottom: 10px;
        }
        
        #experimentCanvas {
            display: block;
            margin: 0 auto;
        }

        /* Controls Styling */
        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
        }

        .slider-container {
            width: 80%;
            text-align: center;
        }

        .slider-container input[type="range"] {
            width: 100%;
        }

        /* Style the slider to match the button color */
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #ddd;
            border-radius: 5px;
            outline: none;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--light-claret);
            cursor: pointer;
            border-radius: 50%;
        }

        input[type=range]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--light-claret);
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
        
        .button-container {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }

        .measure-button {
            background-color: var(--light-claret);
            color: var(--white);
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .measure-button:hover {
            background-color: var(--darker-claret);
        }

        .reset-button {
            position: absolute;
            top: 29px;
            right: 20px;
            transform: translateY(-50%);
            background-color: var(--amber);
            color: var(--claret);
            font-weight: bold;
            border: 1px solid var(--claret);
            padding: 8px 16px;
            border-radius: 5px;
            font-size: 1.0em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .reset-button:hover {
            background-color: #e6ac00; /* Darker amber */
        }
        
        /* New Physics Card Styling */
        .physics-card {
            grid-column: 1 / -1;
            background-color: #FFFFE0; /* Light Yellow */
            padding: 5px 20px 10px;
            transition: background-color 0.4s ease-in-out;
        }

        .physics-card.is-open {
            background-color: var(--white);
        }

        .physics-card summary {
            cursor: pointer;
            font-weight: bold;
            list-style: none;
        }

        .physics-card summary::-webkit-details-marker {
            display: none;
        }

        .physics-card summary > h3 {
            text-align: center;
            border-bottom: none;
            padding-bottom: 0;
            margin-bottom: 0;
        }

        .physics-card.is-open summary > h3 {
            text-align: left;
            border-bottom: 2px solid var(--pale-violet);
            padding-bottom: 10px;
        }

        .physics-content {
            padding-top: 15px;
        }

        .physics-content p {
            line-height: 1.6;
        }

        .diagram-container {
            text-align: center;
            margin: 20px 0;
        }

        .diagram-container svg {
            max-width: 400px;
            width: 100%;
            height: auto;
        }

        /* Advanced Options (Collapsible) Styling */
        .advanced-options-card {
            background-color: #FFFFE0; /* Light Yellow from refractive index sim */
            padding: 5px 20px 10px; /* Made less tall */
        }

        .advanced-options-card h3 {
            border-bottom: none;
            padding-bottom: 0;
            margin-bottom: 0;
        }
        
        details > summary {
            cursor: pointer;
            font-weight: bold;
            list-style: none; /* Remove default marker */
            text-align: center; /* Centered the title */
        }

        details > summary::-webkit-details-marker {
            display: none; /* Remove default marker for Chrome/Safari */
        }

        .advanced-options-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
        }

        .toggle-switch {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        /* Toggle Switch Styling from refractive index sim */
        .switch { position: relative; display: inline-block; width: 60px; height: 34px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider-toggle { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider-toggle:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider-toggle { background-color: #800000; }
        input:checked + .slider-toggle:before { transform: translateX(26px); }


        /* Table Styling */
        .data-table-container {
            max-height: 400px;
            overflow-y: auto;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            text-align: center;
        }

        th, td {
            padding: 8px;
            border: 1px solid black;
        }

        thead th {
            background-color: var(--light-claret);
            color: var(--white);
            position: sticky;
            top: 0;
            z-index: 1;
        }

        /* Ensure sub-header background is also sticky */
        thead tr:nth-child(2) th {
            top: 36px; /* Height of the first header row */
        }
        
        .uncertainty-cell {
            background-color: #FADBD8; /* Light Red from Refractive Index Sim */
        }
    </style>
</head>
<body>

    <header class="header-container">
        <h1 class="header-title">Strathaven Academy Physics Department</h1>
        <h2 class="header-subtitle">Inverse Square Law Simulation</h2>
    </header>

    <div class="main-layout">
        <!-- Background Physics Card -->
        <div class="card physics-card">
            <details id="physicsDetails">
                <summary><h3>Background Physics</h3></summary>
                <div class="physics-content">
                    <p>
                        The inverse square law describes how the intensity of a physical quantity radiating from a point source spreads out in space. For light, this quantity is <strong>irradiance</strong>, which is the power per unit area.
                    </p>
                    <p>
                        A <strong>point source</strong> is an idealized source of light that is treated as a single point in space, radiating energy uniformly in all directions. While no real object is a perfect point source, many can be approximated as one. For this approximation to be valid, the physical size of the source must be much smaller than the distance from the source to the observer. For example, a small light bulb can be treated as a point source in a room, and distant stars are considered point sources when viewed from Earth.
                    </p>
                    <p>
                        Imagine a point source of light with a constant power, $P$, measured in Watts (W). This light energy radiates outwards uniformly in all directions. As the light travels away from the source, it spreads out over the surface of an ever-expanding sphere.
                    </p>
                    <div class="diagram-container">
                        
                        <svg viewBox="0 0 200 100" xmlns="http://www.w3.org/2000/svg">
                            <!-- Point Source -->
                            <circle cx="20" cy="50" r="5" fill="gold" stroke="black" stroke-width="0.5"/>
                            <!-- Light Rays -->
                            <path d="M 25 50 L 180 50" stroke="rgba(255,215,0,0.5)" stroke-width="0.5"/>
                            <path d="M 23.5 46.5 L 160 20" stroke="rgba(255,215,0,0.5)" stroke-width="0.5"/>
                            <path d="M 23.5 53.5 L 160 80" stroke="rgba(255,215,0,0.5)" stroke-width="0.5"/>

                            <!-- Inner Sphere -->
                            <circle cx="20" cy="50" r="30" fill="none" stroke="black" stroke-width="0.5" stroke-dasharray="2,2"/>
                            <!-- Outer Sphere -->
                            <circle cx="20" cy="50" r="60" fill="none" stroke="black" stroke-width="0.5" stroke-dasharray="2,2"/>
                            
                            <!-- Area Patches -->
                            <path d="M 48, 41.34 C 49, 41.6 50, 42.1 50, 42.68 L 50 57.32 C 50, 57.9 49, 58.4 48, 58.66" fill="rgba(176, 58, 46, 0.3)" stroke="rgba(128, 0, 0, 0.7)" stroke-width="0.5"/>
                            <path d="M 75.3, 31.4 C 77, 32.2 79.5, 34 80, 35 L 80 65 C 79.5, 66 77, 67.8 75.3, 68.6" fill="rgba(176, 58, 46, 0.3)" stroke="rgba(128, 0, 0, 0.7)" stroke-width="0.5"/>

                            <!-- Labels -->
                            <line x1="20" y1="50" x2="50" y2="50" stroke="black" stroke-width="0.7"/>
                            <text x="35" y="47" font-size="5" text-anchor="middle">d</text>
                            <line x1="20" y1="50" x2="80" y2="50" stroke="black" stroke-width="0.7"/>
                            <text x="50" y="56" font-size="5" text-anchor="middle">2d</text>
                            
                            <text x="53" y="50" font-size="5" text-anchor="start">Area, A</text>
                            <text x="83" y="50" font-size="5" text-anchor="start">Area, 4A</text>
                        </svg>
                    </div>
                    <p>
                        The surface area of a sphere is given by the formula $A = 4\pi d^2$, where $d$ is the distance (radius) from the point source. The irradiance, $I$, is the total power of the source divided by the area over which it is spread:
                        $$ I = \frac{P}{A} = \frac{P}{4\pi d^2} $$
                    </p>
                    <p>
                        Since the power of the source ($P$) and the term $4\pi$ are constants, we can group them into a single constant of proportionality, $k$. This shows that the irradiance is inversely proportional to the square of the distance from the source:
                        $$ I = \frac{k}{d^2} \quad \text{or} \quad I \propto \frac{1}{d^2} $$
                    </p>
                    <p>
                        By plotting a graph of irradiance, $I$, on the y-axis against $1/d^2$ on the x-axis, we can verify this relationship. The equation $I = k/d^2$ can be compared to the equation of a straight line, $y = mx + c$. In this case, $y$ is $I$, $x$ is $1/d^2$, and the y-intercept $c$ is zero. This means the gradient of the line, $m$, is equal to the constant of proportionality, $k$.
                    </p>
                     <p>
                        This is the inverse square law. It means that if you double the distance from the source, the irradiance drops to one-quarter of its original value. If you triple the distance, it drops to one-ninth. This relationship is what you will investigate and verify in this experiment.
                    </p>
                </div>
            </details>
        </div>

        <!-- Left Panel -->
        <div class="panel">
            <div class="card" style="position: relative;">
                <button id="resetButton" class="reset-button">Reset</button>
                <h3>Experiment Setup</h3>
                <canvas id="experimentCanvas" width="600" height="250"></canvas>
                <div class="controls">
                    <div class="slider-container">
                        <label for="distanceSlider">Distance, d = <span id="distanceValue">0.50</span> m</label>
                        <input type="range" id="distanceSlider" min="0.20" max="1.00" step="0.01" value="0.50">
                    </div>
                    <div class="button-container">
                        <button id="measureButton" class="measure-button">Measure Irradiance</button>
                    </div>
                </div>
            </div>

            <div class="card advanced-options-card">
                <details>
                    <summary><h3>Advanced Options</h3></summary>
                    <div class="advanced-options-controls">
                        <div class="toggle-switch">
                            <label for="uncertaintyToggle">Enable Random Uncertainty:</label>
                            <label class="switch">
                                <input type="checkbox" id="uncertaintyToggle">
                                <span class="slider-toggle"></span>
                            </label>
                        </div>
                        <div class="toggle-switch">
                            <label for="backgroundToggle">Enable Background Light:</label>
                            <label class="switch">
                                <input type="checkbox" id="backgroundToggle">
                                <span class="slider-toggle"></span>
                            </label>
                        </div>
                    </div>
                </details>
            </div>

            <div class="card">
                <h3>Results</h3>
                <div id="resultsOutput">
                    <p>Collect at least two data points to calculate the gradient.</p>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="panel">
            <div class="card">
                <h3>Results Table</h3>
                <div class="data-table-container">
                    <table>
                        <thead>
                            <tr>
                                <th rowspan="2">Distance (m)</th>
                                <th colspan="4">Irradiance (W m⁻²)</th>
                                <th rowspan="2">1/d² (m⁻²)</th>
                                <th rowspan="2">k = Id² (W)</th>
                                <th rowspan="2">Random Uncertainty<br>in Irradiance (W m⁻²)</th>
                            </tr>
                            <tr>
                                <th>I₁</th>
                                <th>I₂</th>
                                <th>I₃</th>
                                <th>Mean, Ī</th>
                            </tr>
                        </thead>
                        <tbody id="dataTableBody">
                            <!-- Data rows will be inserted here -->
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="card">
                <h3>Graph of Irradiance vs. 1 / Distance Squared</h3>
                <canvas id="resultsGraph"></canvas>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const katexOptions = {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false},
                    {left: '\\(', right: '\\)', display: false},
                    {left: '\\[', right: '\\]', display: true}
                ],
                throwOnError : false
            };
            
             if (window.renderMathInElement) {
                renderMathInElement(document.body, katexOptions);
            }

            // --- DOM ELEMENTS ---
            const canvas = document.getElementById('experimentCanvas');
            const ctx = canvas.getContext('2d');
            const slider = document.getElementById('distanceSlider');
            const distanceValueSpan = document.getElementById('distanceValue');
            const measureButton = document.getElementById('measureButton');
            const resetButton = document.getElementById('resetButton');
            const uncertaintyToggle = document.getElementById('uncertaintyToggle');
            const backgroundToggle = document.getElementById('backgroundToggle');
            const dataTableBody = document.getElementById('dataTableBody');
            const resultsOutput = document.getElementById('resultsOutput');
            const graphCtx = document.getElementById('resultsGraph').getContext('2d');
            const physicsDetails = document.getElementById('physicsDetails');

            // --- CONSTANTS & STATE ---
            const K_CONSTANT = 10.0; // The "true" constant of proportionality in Watts
            const BACKGROUND_IRRADIANCE = 10.0; // Constant background light in W m⁻²
            let dataPoints = [];
            let chart;

            // --- SLIDER FILL ---
            function updateSliderFill() {
                const percentage = ((slider.value - slider.min) / (slider.max - slider.min)) * 100;
                slider.style.background = `linear-gradient(to right, var(--light-claret) ${percentage}%, #ddd ${percentage}%)`;
            }

            // --- CANVAS DRAWING ---
            function drawScene(distance) {
                const canvasWidth = canvas.width;
                const canvasHeight = canvas.height;
                const meterStickY = 180;
                const meterStickHeight = 10;
                const bulbX = 50;
                const scale = (canvasWidth - 150) / 1.0; // pixels per meter
                const gap = 10; // Gap between stick and components

                ctx.clearRect(0, 0, canvasWidth, canvasHeight);

                // 1. Draw Meter Stick
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.fillRect(bulbX, meterStickY, scale * 1.0, meterStickHeight);
                ctx.strokeRect(bulbX, meterStickY, scale * 1.0, meterStickHeight);

                ctx.fillStyle = 'black';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                for (let i = 0; i <= 10; i++) {
                    const x = bulbX + i * 0.1 * scale;
                    ctx.beginPath();
                    ctx.moveTo(x, meterStickY);
                    ctx.lineTo(x, meterStickY + meterStickHeight / 2);
                    ctx.stroke();
                    if (i === 0 || i === 10) {
                        const label = (i / 10).toFixed(1);
                        ctx.fillText(label, x, meterStickY + meterStickHeight + 12);
                    }
                }

                // 2. Draw Light Bulb
                const bulbBottomY = meterStickY - gap;
                const holderHeight = 15;
                const holderWidth = 24;
                const bulbRadius = 20;
                const bulbCircleCenterY = bulbBottomY - holderHeight - bulbRadius;
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.strokeRect(bulbX - holderWidth / 2, bulbBottomY - holderHeight, holderWidth, holderHeight);
                ctx.beginPath();
                ctx.arc(bulbX, bulbCircleCenterY, bulbRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(bulbX - 5, bulbCircleCenterY + 5);
                ctx.lineTo(bulbX - 5, bulbCircleCenterY - 5);
                ctx.moveTo(bulbX + 5, bulbCircleCenterY + 5);
                ctx.lineTo(bulbX + 5, bulbCircleCenterY - 5);
                ctx.stroke();
                ctx.strokeStyle = 'rgba(255, 191, 0, 0.5)';
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(bulbX, bulbCircleCenterY);
                    ctx.lineTo(bulbX + Math.cos(angle) * (bulbRadius + 10), bulbCircleCenterY + Math.sin(angle) * (bulbRadius + 10));
                    ctx.stroke();
                }
                ctx.fillStyle = 'black';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Point Source', bulbX, bulbCircleCenterY - bulbRadius - 22);
                ctx.fillText('of Light', bulbX, bulbCircleCenterY - bulbRadius - 10);

                // 3. Draw Photocell (Sensor) and Multimeter
                const photocellX = bulbX + distance * scale;
                const photocellY = meterStickY - 40 - gap;
                ctx.fillStyle = '#555';
                ctx.fillRect(photocellX - 10, photocellY, 20, 40);
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(photocellX - 8, photocellY + 2, 16, 16);
                ctx.fillStyle = 'black';
                ctx.fillText('Light Sensor', photocellX, photocellY - 5);
                
                const multimeterX = photocellX + 40;
                const multimeterY = meterStickY - 50 - gap;
                ctx.fillStyle = '#333';
                ctx.fillRect(multimeterX, multimeterY, 100, 50);
                ctx.fillStyle = '#90EE90';
                ctx.fillRect(multimeterX + 5, multimeterY + 5, 90, 30);
                ctx.fillStyle = 'black';
                ctx.fillText('Multimeter', multimeterX + 50, multimeterY - 5);
                
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(photocellX + 10, photocellY + 20);
                ctx.lineTo(multimeterX, photocellY + 20);
                ctx.stroke();

                const currentIrradiance = calculateIrradiance(distance);
                const textY = multimeterY + 23;
                ctx.fillStyle = 'black';
                ctx.font = '14px "Courier New", monospace';
                ctx.textAlign = 'right';
                ctx.fillText(currentIrradiance.toFixed(2), multimeterX + 90, textY);
                ctx.font = '10px "Courier New", monospace';
                ctx.fillText('W m⁻²', multimeterX + 88, textY + 10);
            }

            // --- CALCULATIONS ---
            function calculateIrradiance(d) {
                let irradiance = K_CONSTANT / (d * d);
                if (uncertaintyToggle.checked) {
                    const uncertaintyFactor = (Math.random() - 0.5) * 0.1; // +/- 5% random error
                    irradiance *= (1 + uncertaintyFactor);
                }
                if (backgroundToggle.checked) {
                    irradiance += BACKGROUND_IRRADIANCE;
                }
                return irradiance;
            }
            
            function calculateBestFit() {
                const validPoints = dataPoints.filter(p => p.meanI !== null);
                if (validPoints.length < 2) return null;

                let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
                const n = validPoints.length;

                validPoints.forEach(p => {
                    const x = p.invDSq;
                    const y = p.meanI;
                    sumX += x;
                    sumY += y;
                    sumXY += x * y;
                    sumX2 += x * x;
                });

                const gradient = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                const intercept = (sumY - gradient * sumX) / n;
                
                return { gradient, intercept };
            }

            // --- UPDATERS ---
            function updateTable() {
                dataTableBody.innerHTML = '';
                
                dataPoints.forEach(p => {
                    const i1 = p.irradiances[0] !== undefined ? p.irradiances[0].toFixed(2) : '-';
                    const i2 = p.irradiances[1] !== undefined ? p.irradiances[1].toFixed(2) : '-';
                    const i3 = p.irradiances[2] !== undefined ? p.irradiances[2].toFixed(2) : '-';
                    const mean = p.meanI !== null ? p.meanI.toFixed(2) : '-';
                    const k = p.kExp !== null ? p.kExp.toFixed(2) : '-';
                    const uncertainty = p.uncertainty !== null ? p.uncertainty.toFixed(2) : '-';

                    const row = `
                        <tr>
                            <td>${p.d.toFixed(2)}</td>
                            <td>${i1}</td>
                            <td>${i2}</td>
                            <td>${i3}</td>
                            <td><b>${mean}</b></td>
                            <td>${p.invDSq.toFixed(2)}</td>
                            <td>${k}</td>
                            <td class="uncertainty-cell">${uncertainty}</td>
                        </tr>
                    `;
                    dataTableBody.innerHTML += row;
                });

                const emptyRowsNeeded = Math.max(0, 5 - dataPoints.length);
                for (let i = 0; i < emptyRowsNeeded; i++) {
                    const emptyRow = `<tr><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td class="uncertainty-cell">-</td></tr>`;
                    dataTableBody.innerHTML += emptyRow;
                }
            }
            
            function updateResults() {
                const fit = calculateBestFit();
                if (!fit) {
                    resultsOutput.innerHTML = '<p>Collect at least two data points to calculate the gradient.</p>';
                    return;
                }

                const gradient = fit.gradient;
                const intercept = fit.intercept;
                let katexString;

                if (backgroundToggle.checked) {
                    katexString = `
                        <p>With background light, the relationship becomes $Ī = k \\times \\frac{1}{d^2} + C$, where C is the background irradiance.</p>
                        <p>The gradient of the line still gives the value for $k$, and the y-intercept gives the value for the background light, $C$.</p>
                    `;
                } else {
                    katexString = `
                        <p>The graph of $Ī$ against $\\frac{1}{d^2}$ should be a straight line through the origin, as the relationship is $Ī = k \\times \\frac{1}{d^2}$.</p>
                        <p>The gradient of this line gives the experimental value for the constant of proportionality, $k$.</p>
                    `;
                }
                
                if (chart && chart.gradientPoints) {
                    const { p1, p2 } = chart.gradientPoints;
                    katexString += `
                        <p><b>Calculation:</b></p>
                        <p>$$ k = \\text{gradient} = \\frac{y_2 - y_1}{x_2 - x_1} $$</p>
                        <p>$$ k = \\frac{${p2.y.toFixed(2)} - ${p1.y.toFixed(2)}}{${p2.x.toFixed(2)} - ${p1.x.toFixed(2)}} = \\frac{${(p2.y - p1.y).toFixed(2)}}{${(p2.x - p1.x).toFixed(2)}} $$</p>
                    `;
                }

                katexString += `<p><b>Gradient (k) = ${gradient.toFixed(3)} W</b></p>`;
                if (backgroundToggle.checked) {
                    katexString += `<p><b>Y-Intercept (C) = ${intercept.toFixed(3)} W m⁻²</b></p>`;
                }

                resultsOutput.innerHTML = katexString;
                
                 if (window.renderMathInElement) {
                    renderMathInElement(resultsOutput, katexOptions);
                 }
            }

            function updateGraph() {
                const scatterData = dataPoints
                    .filter(p => p.meanI !== null)
                    .map(p => ({ x: p.invDSq, y: p.meanI }));
                
                chart.data.datasets[0].data = scatterData;

                const fit = calculateBestFit();

                if (fit) {
                    const xValues = scatterData.map(p => p.x).sort((a,b) => a - b);
                    if (xValues.length > 0) {
                        const minX = xValues[0]; // For triangle calculation
                        const maxX = xValues[xValues.length - 1]; // For triangle calculation
                        
                        // Extrapolate the best-fit line to the edges of the graph
                        chart.data.datasets[1].data = [
                            { x: 0, y: fit.gradient * 0 + fit.intercept },
                            { x: 26, y: fit.gradient * 26 + fit.intercept }
                        ];

                        // Logic for gradient triangle
                        const scaleX = chart.scales.x;
                        const xTicks = scaleX.ticks.map(t => t.value).filter(t => t >= minX && t <= maxX);
                        
                        let p1 = { x: minX, y: fit.gradient * minX + fit.intercept };
                        let p2 = { x: maxX, y: fit.gradient * maxX + fit.intercept };
                        let maxDist = 0;

                        if (xTicks.length >= 2) {
                             for (let i = 0; i < xTicks.length; i++) {
                                for (let j = i + 1; j < xTicks.length; j++) {
                                    const x1 = xTicks[i];
                                    const x2 = xTicks[j];
                                    const y1 = fit.gradient * x1 + fit.intercept;
                                    const y2 = fit.gradient * x2 + fit.intercept;
                                    
                                    const dist = Math.hypot(x2 - x1, y2 - y1);
                                    if (dist > maxDist) {
                                        maxDist = dist;
                                        p1 = { x: x1, y: y1 };
                                        p2 = { x: x2, y: y2 };
                                    }
                                }
                            }
                        }

                        chart.gradientPoints = { p1, p2 };
                        
                        chart.data.datasets[2].data = [
                            { x: p1.x, y: p1.y },
                            { x: p2.x, y: p1.y },
                            { x: p2.x, y: p2.y }
                        ];
                    }
                } else {
                     chart.data.datasets[1].data = [];
                     chart.data.datasets[2].data = [];
                     chart.gradientPoints = null;
                }
                
                chart.update();
            }

            function initChart() {
                chart = new Chart(graphCtx, {
                    data: {
                        datasets: [
                            { type: 'scatter', label: 'Data Points', data: [], backgroundColor: 'rgba(176, 58, 46, 0.8)', borderColor: 'rgba(128, 0, 0, 1)' },
                            { type: 'line', label: 'Best-Fit Line', data: [], borderColor: 'rgba(0, 0, 0, 0.7)', borderWidth: 2, fill: false, pointRadius: 0 },
                            {
                                type: 'line',
                                label: 'Gradient Calculation',
                                data: [],
                                borderColor: 'rgba(0, 128, 0, 0.7)',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                fill: false,
                                pointRadius: 5,
                                pointBackgroundColor: 'rgba(0, 128, 0, 0.7)',
                                showInLegend: false
                            }
                        ]
                    },
                    options: {
                        scales: {
                            x: { type: 'linear', position: 'bottom', title: { display: true, text: '1/d² (m⁻²)' }, beginAtZero: true, max: 26, ticks: { stepSize: 2 }, grid: { color: '#aaaaaa' }, border: { color: 'black', width: 2 } },
                            y: { title: { display: true, text: 'Mean Irradiance, Ī (W m⁻²)' }, beginAtZero: true, max: 260, ticks: { stepSize: 20 }, grid: { color: '#aaaaaa' }, border: { color: 'black', width: 2 } }
                        },
                        plugins: { 
                            tooltip: { callbacks: { label: function(context) { let label = context.dataset.label || ''; if (label) { label += ': '; } if (context.parsed.y !== null) { label += `(1/d²: ${context.parsed.x.toFixed(2)}, Ī: ${context.parsed.y.toFixed(2)})`; } return label; } } },
                            legend: {
                                filter: function(legendItem, chartData) {
                                    // Only show the legend item if its corresponding dataset has data.
                                    return chartData.datasets[legendItem.datasetIndex].data.length > 0;
                                }
                            }
                        }
                    }
                });
            }

            function resetData() {
                dataPoints = [];
                updateTable();
                updateGraph();
                updateResults();
                drawScene(parseFloat(slider.value)); // Redraw multimeter
            }

            // --- EVENT LISTENERS ---
            slider.addEventListener('input', () => {
                const distance = parseFloat(slider.value);
                distanceValueSpan.textContent = distance.toFixed(2);
                drawScene(distance);
                updateSliderFill();
            });

            resetButton.addEventListener('click', resetData);
            uncertaintyToggle.addEventListener('change', resetData);
            backgroundToggle.addEventListener('change', resetData);

            physicsDetails.addEventListener('toggle', () => {
                physicsDetails.parentElement.classList.toggle('is-open', physicsDetails.open);
                 if (physicsDetails.open) {
                    // KaTeX may need a moment to reflow, re-render after transition
                    setTimeout(() => {
                        if (window.renderMathInElement) {
                            renderMathInElement(physicsDetails, katexOptions);
                        }
                    }, 400); // Should be same as transition time
                }
            });

            measureButton.addEventListener('click', () => {
                const d = parseFloat(slider.value);
                const newIrradiance = calculateIrradiance(d);

                let existingPoint = dataPoints.find(p => p.d === d);

                if (existingPoint) {
                    if (existingPoint.irradiances.length < 3) {
                        existingPoint.irradiances.push(newIrradiance);
                    } else {
                        return; 
                    }
                } else {
                    existingPoint = {
                        d: d,
                        irradiances: [newIrradiance],
                        invDSq: 1 / (d * d),
                        meanI: null,
                        kExp: null,
                        uncertainty: null
                    };
                    dataPoints.push(existingPoint);
                }

                const sum = existingPoint.irradiances.reduce((a, b) => a + b, 0);
                existingPoint.meanI = sum / existingPoint.irradiances.length;
                existingPoint.kExp = (existingPoint.meanI - (backgroundToggle.checked ? BACKGROUND_IRRADIANCE : 0)) * existingPoint.d * existingPoint.d;
                
                if (existingPoint.irradiances.length > 1) {
                    const max = Math.max(...existingPoint.irradiances);
                    const min = Math.min(...existingPoint.irradiances);
                    existingPoint.uncertainty = (max - min) / existingPoint.irradiances.length;
                } else {
                    existingPoint.uncertainty = null;
                }
                
                dataPoints.sort((a, b) => a.d - b.d);

                updateTable();
                updateGraph();
                updateResults();
            });

            // --- INITIALIZATION CALL ---
            drawScene(parseFloat(slider.value));
            initChart();
            updateTable(); 
            updateSliderFill();
        });
    </script>
</body>
</html>







<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Steph Taylor">
    <meta name="version" content="2.00.00">

    <title>Internal Resistance of a Cell from an R vs 1/I Graph</title>

    <!-- KaTeX for LaTeX rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" xintegrity="sha384-sCutvgpopvms1PSRPY+ax+sUpl1jsmm4w6+ERsYSJOiS2BZAoAx1+t1JdGjV3b85" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" xintegrity="sha384-hIoBPJpTadox55GCNM+PBOZpTmxH+SSt+HkexsB4rUIeGajGAXXfEaY9sm2RXP5L" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" xintegrity="sha384-43gviWU0YVjaDtb/Gf1I3Oths0VyDsAlpOvx8v2iIAMoZgKcrypMe7Au17VebouV" crossorigin="anonymous"></script>

    <!-- Chart.js for graphing -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        :root {
            --claret: #800000;
            --light-claret: #B03A2E;
            --darker-claret: #8a2e24;
            --amber: #FFBF00;
            --blush-pink: #F1D4D4;
            --pale-violet: #E6E6FA;
            --white: #FFFFFF;
            --black: #000000;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: var(--pale-violet);
            margin: 0;
            padding: 20px;
        }

        /* Header Styling */
        .header-container {
            background-color: var(--claret);
            border-radius: 10px;
            border: 2px solid var(--black);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            text-align: center;
            padding: 20px;
            margin-bottom: 20px;
            color: var(--white);
        }

        .header-title {
            color: var(--amber);
            font-weight: bold;
            font-size: 2em;
            margin: 0;
            font-family: Arial, sans-serif; /* Matched from Refractive Index Sim */
        }

        .header-subtitle {
            color: var(--blush-pink);
            font-size: 1.5em;
            margin: 0; /* Adjusted margin */
            font-family: Arial, sans-serif; /* Matched from Refractive Index Sim */
            font-weight: normal; /* Matched from Refractive Index Sim */
        }

        /* Layout Styling */
        .main-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            align-items: start;
        }

        @media (max-width: 1000px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Card Styling */
        .card {
            background-color: var(--white);
            border-radius: 10px;
            border: 2px solid var(--black);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            padding: 20px;
        }

        .card h3 {
            margin-top: 0;
            border-bottom: 2px solid var(--pale-violet);
            padding-bottom: 10px;
        }
        
        #experimentCanvas {
            display: block;
            margin: 0 auto;
            background-color: var(--white);
            border-radius: 5px;
        }

        /* Controls Styling */
        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
        }

        .slider-container {
            width: 80%;
            text-align: center;
        }

        .slider-container input[type="range"] {
            width: 100%;
        }

        /* Style the slider to match the button color */
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #ddd;
            border-radius: 5px;
            outline: none;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--light-claret);
            cursor: pointer;
            border-radius: 50%;
        }

        input[type=range]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--light-claret);
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
        
        .button-container {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }

        .measure-button {
            background-color: var(--light-claret);
            color: var(--white);
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .measure-button:hover {
            background-color: var(--darker-claret);
        }

        .reset-button {
            position: absolute;
            top: 29px;
            right: 20px;
            transform: translateY(-50%);
            background-color: var(--amber);
            color: var(--claret);
            font-weight: bold;
            border: 1px solid var(--claret);
            padding: 8px 16px;
            border-radius: 5px;
            font-size: 1.0em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .reset-button:hover {
            background-color: #e6ac00; /* Darker amber */
        }
        
        /* New Physics Card Styling */
        .physics-card {
            grid-column: 1 / -1;
            background-color: #FFFFE0; /* Light Yellow */
            padding: 5px 20px 10px;
            transition: background-color 0.4s ease-in-out;
        }

        .physics-card.is-open {
            background-color: var(--white);
        }

        .physics-card summary {
            cursor: pointer;
            font-weight: bold;
            list-style: none;
        }

        .physics-card summary::-webkit-details-marker {
            display: none;
        }

        .physics-card summary > h3 {
            text-align: center;
            border-bottom: none;
            padding-bottom: 0;
            margin-bottom: 0;
        }

        .physics-card.is-open summary > h3 {
            text-align: left;
            border-bottom: 2px solid var(--pale-violet);
            padding-bottom: 10px;
        }

        .physics-content {
            padding-top: 15px;
        }

        .physics-content p {
            line-height: 1.6;
        }

        /* Advanced Options (Collapsible) Styling */
        .advanced-options-card {
            background-color: #FFFFE0; /* Light Yellow from refractive index sim */
            padding: 5px 20px 10px; /* Made less tall */
        }

        .advanced-options-card h3 {
            border-bottom: none;
            padding-bottom: 0;
            margin-bottom: 0;
        }
        
        details > summary {
            cursor: pointer;
            font-weight: bold;
            list-style: none; /* Remove default marker */
            text-align: center; /* Centered the title */
        }

        details > summary::-webkit-details-marker {
            display: none; /* Remove default marker for Chrome/Safari */
        }

        .advanced-options-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
        }

        .toggle-switch {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        /* Toggle Switch Styling from refractive index sim */
        .switch { position: relative; display: inline-block; width: 60px; height: 34px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider-toggle { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider-toggle:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider-toggle { background-color: #800000; }
        input:checked + .slider-toggle:before { transform: translateX(26px); }


        /* Table Styling */
        .data-table-container {
            max-height: 400px;
            overflow-y: auto;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            text-align: center;
        }

        th, td {
            padding: 8px;
            border: 1px solid black;
        }

        thead th {
            background-color: var(--light-claret);
            color: var(--white);
            position: sticky;
            top: 0;
            z-index: 1;
        }

        /* Ensure sub-header background is also sticky */
        thead tr:nth-child(2) th {
            top: 36px; /* Height of the first header row */
        }
        
        .uncertainty-cell {
            background-color: #FADBD8; /* Light Red from Refractive Index Sim */
        }

        #graph-card {
            min-height: 400px;
            display: flex;
            flex-direction: column;
        }

        .graph-container {
            position: relative;
            flex-grow: 1;
        }

        .cell-selector-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .cell-selector-container select {
            padding: 5px;
            border-radius: 5px;
            border: 1px solid #ccc;
            font-size: 1em;
        }

        .serif {
            font-family: 'Times New Roman', Times, serif;
        }
    </style>
</head>
<body>

    <header class="header-container">
        <h1 class="header-title">Strathaven Academy Physics Department</h1>
        <h2 class="header-subtitle">Finding the Internal Resistance of a Cell Using an R vs 1/<span class="serif">I</span> Graph</h2>
    </header>

    <div class="main-layout">
        <!-- Background Physics Card -->
        <div class="card physics-card">
            <details id="physicsDetails">
                <summary><h3>Background Physics</h3></summary>
                <div class="physics-content">
                    <h4>Circuit Analysis</h4>
                    <p>The relationship between the <strong>electromotive force (EMF, $E$)</strong> of a cell, its <strong>internal resistance ($r$)</strong>, the <strong>load resistance ($R$)</strong>, and the <strong>current ($I$)</strong> flowing in the circuit is given by the equation:
                    $$ E = I(R + r) $$
                    This can be expanded to:
                    $$ E = IR + Ir $$
                    From Ohm's Law, the term $IR$ is the potential difference across the external load resistor, which we call the <strong>terminal potential difference ($V$)</strong>. The term $Ir$ is the potential difference across the internal resistance, known as the <strong>"lost volts"</strong>.</p>
                    
                    <div style="text-align: center; margin: 20px 0;">
                        <img src="internal resistance b1.webp" alt="Circuit diagram showing a real power source model" style="max-width: 400px;">
                        <p style="font-size: 0.9em; color: #555; margin-top: 5px;">A real power source can be modelled as an ideal EMF ($E$) in series with an internal resistance ($r$).</p>
                    </div>

                    <h4>Determining E and r Graphically</h4>
                    <p>To determine the EMF and internal resistance experimentally, we can rearrange the governing equation into the form of a straight line, $y = mx + c$. We will measure the current $I$ for various settings of the load resistance $R$.
                    Starting from $E = I(R+r)$, we can divide by $I$:
                    $$ \frac{E}{I} = R + r $$
                    Now, making the load resistance $R$ the subject of the formula gives:
                    $$ R = \frac{E}{I} - r $$
                    This can be rewritten as:
                    $$ R = E \left(\frac{1}{I}\right) - r $$
                    This equation is now in the form of a straight line, <strong>$y = mx + c$</strong>, where:</p>
                    <ul>
                        <li>$y$ corresponds to the Load Resistance, $R$.</li>
                        <li>$x$ corresponds to the reciprocal of the Current, $1/I$.</li>
                        <li>The <strong>gradient ($m$)</strong> corresponds to the <strong>EMF ($E$)</strong>.</li>
                        <li>The <strong>y-intercept ($c$)</strong> corresponds to the <strong>negative internal resistance ($-r$)</strong>.</li>
                    </ul>
                    <p>By measuring several pairs of values for $R$ and $I$, you can plot a graph of $R$ against $1/I$. The gradient of the best-fit line gives you the EMF, and the negative of the y-intercept gives the internal resistance.</p>
                    <div style="text-align: center; margin: 20px 0;">
                        <img src="internal resistance b2.webp" alt="Graph of Load Resistance vs 1/Current showing EMF and gradient" style="max-width: 400px;">
                        <p style="font-size: 0.9em; color: #555; margin-top: 5px;">The graph of R vs 1/current is a straight line. The gradient is the EMF ($E$) and the y-intercept is the negative internal resistance ($-r$).</p>
                    </div>
                </div>
            </details>
        </div>

        <!-- Left Panel -->
        <div class="panel">
            <div class="card" style="position: relative;">
                <button id="resetButton" class="reset-button">Reset</button>
                <h3>Experiment Setup</h3>
                <div class="cell-selector-container">
                    <label for="cellTypeSelector">Type of cell:</label>
                    <select id="cellTypeSelector">
                        <option value="D">D Cell</option>
                        <option value="car">Car Battery</option>
                        <option value="9V">9 V Cell</option>
                    </select>
                </div>
                <canvas id="experimentCanvas" width="600" height="350"></canvas>
                <div class="controls">
                    <div class="slider-container">
                        <label for="resistanceSlider">Load Resistance, R = <span id="resistanceValue">1.0</span> Ω</label>
                        <input type="range" id="resistanceSlider" min="0.1" max="2.0" step="0.01" value="1.0">
                    </div>
                    <div class="button-container">
                        <button id="measureButton" class="measure-button">Take Readings</button>
                    </div>
                </div>
            </div>

            <div class="card advanced-options-card">
                <details>
                    <summary><h3>Advanced Options</h3></summary>
                    <div class="advanced-options-controls">
                        <div class="toggle-switch">
                            <label for="uncertaintyToggle">Enable Random Uncertainty:</label>
                            <label class="switch">
                                <input type="checkbox" id="uncertaintyToggle">
                                <span class="slider-toggle"></span>
                            </label>
                        </div>
                    </div>
                </details>
            </div>

            <div class="card">
                <h3>Results</h3>
                <div id="resultsOutput">
                    <p>Collect at least two data points to calculate the gradient.</p>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="panel">
            <div class="card">
                <h3>Results Table</h3>
                <div class="data-table-container">
                    <table>
                        <thead>
                            <tr>
                                <th rowspan="2">Resistance, R (Ω)</th>
                                <th colspan="4">Current (A)</th>
                                <th rowspan="2">1/<span class="serif">I</span> (A⁻¹)</th>
                                <th rowspan="2">Random Uncertainty<br>in Current (A)</th>
                            </tr>
                            <tr>
                                <th><span class="serif">I</span>₁</th>
                                <th><span class="serif">I</span>₂</th>
                                <th><span class="serif">I</span>₃</th>
                                <th>Mean <span class="serif">I</span></th>
                            </tr>
                        </thead>
                        <tbody id="dataTableBody">
                            <!-- Data rows will be inserted here -->
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="card" id="graph-card">
                <h3>Graph of Load Resistance vs. 1/current</h3>
                <div class="graph-container">
                    <canvas id="resultsGraph"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const katexOptions = {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false},
                    {left: '\\(', right: '\\)', display: false},
                    {left: '\\[', right: '\\]', display: true}
                ],
                throwOnError : false
            };
            
             if (window.renderMathInElement) {
                 renderMathInElement(document.body, katexOptions);
             }

            // --- DOM ELEMENTS ---
            const canvas = document.getElementById('experimentCanvas');
            const ctx = canvas.getContext('2d');
            const slider = document.getElementById('resistanceSlider');
            const resistanceValueSpan = document.getElementById('resistanceValue');
            const measureButton = document.getElementById('measureButton');
            const resetButton = document.getElementById('resetButton');
            const uncertaintyToggle = document.getElementById('uncertaintyToggle');
            const dataTableBody = document.getElementById('dataTableBody');
            const resultsOutput = document.getElementById('resultsOutput');
            const graphCtx = document.getElementById('resultsGraph').getContext('2d');
            const physicsDetails = document.getElementById('physicsDetails');
            const cellTypeSelector = document.getElementById('cellTypeSelector');

            // --- CONSTANTS & STATE ---
            const cellTypes = {
                'D':   { name: 'D Cell',      emf: 1.5,  minR: 0.20, maxR: 0.35,  sliderMin: 0.1,   sliderMax: 2.0,   sliderStep: 0.01,  graphRecipIMax: 1.6, graphRMax: 2.5,  graphRMin: -0.5, graphRecipIStep: 0.2, graphRStep: 0.5 },
                'car': { name: 'Car Battery', emf: 12.6, minR: 0.01, maxR: 0.03,  sliderMin: 0.01,  sliderMax: 0.1,   sliderStep: 0.001, graphRecipIMax: 0.01, graphRMax: 0.1,  graphRMin: -0.05, graphRecipIStep: 0.001, graphRStep: 0.02 },
                '9V':  { name: '9 V Cell',    emf: 9.0,  minR: 1.0,  maxR: 2.5,   sliderMin: 2.0,   sliderMax: 10.0,  sliderStep: 0.1,   graphRecipIMax: 1.5, graphRMax: 12.0, graphRMin: -3.0, graphRecipIStep: 0.2, graphRStep: 2 }
            };

            let EMF; // Volts - will be set by cell type
            let internalResistance; // Ohms - will be randomized
            let dataPoints = [];
            let chart;
            let lastCalculatedCurrent = null;

            function randomizeInternalResistance() {
                const selectedCellKey = cellTypeSelector.value;
                const cell = cellTypes[selectedCellKey];
                const min = cell.minR;
                const max = cell.maxR;
                const randomValue = Math.random() * (max - min) + min;
                internalResistance = parseFloat(randomValue.toFixed(cell.sliderStep < 0.01 ? 3 : 2));
            }

            // --- SLIDER FILL ---
            function updateSliderFill() {
                const percentage = ((slider.value - slider.min) / (slider.max - slider.min)) * 100;
                slider.style.background = `linear-gradient(to right, var(--light-claret) ${percentage}%, #ddd ${percentage}%)`;
            }

            // --- CANVAS DRAWING ---
            function roundRect(ctx, x, y, width, height, radius) {
              if (width < 2 * radius) radius = width / 2;
              if (height < 2 * radius) radius = height / 2;
              ctx.beginPath();
              ctx.moveTo(x + radius, y);
              ctx.arcTo(x + width, y, x + width, y + height, radius);
              ctx.arcTo(x + width, y + height, x, y + height, radius);
              ctx.arcTo(x, y + height, x, y, radius);
              ctx.arcTo(x, y, x + width, y, radius);
              ctx.closePath();
            }

            function drawScene(loadResistance) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'black';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';

                const horizontalOffset = 100;
                
                // --- Component positions ---
                const cellX = 100 + horizontalOffset;
                const circuitRightX = 400 + horizontalOffset;
                const topWireY = 75;
                const bottomWireY = 300;
                
                const ammeterPos = { x: (cellX + circuitRightX) / 2, y: topWireY };
                const resPos = { x: (cellX + circuitRightX) / 2, y: bottomWireY };
                
                const selectedCellKey = cellTypeSelector.value;
                const cell = cellTypes[selectedCellKey];
                const cellCenterY = (topWireY + bottomWireY) / 2;

                // --- Draw Cell Type Label ---
                ctx.save();
                ctx.fillStyle = 'black';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(cell.name, 70, cellCenterY);
                ctx.restore();

                const leadConnectYOffset = 28;
                const leadWidth = 10;
                const leadHeight = 2;
                const meterWidth = 70;
                const meterHeight = 60;
                const cornerRadius = 5;
                const wireOffsetY = 20;
                let posConnection, negConnection;

                // --- Draw Cell (Identical to previous version) ---
                if (selectedCellKey === 'D') {
                    const cellWidth = 40;
                    const mainBodyHeight = 90;
                    const mainBodyY = cellCenterY - mainBodyHeight / 2;
                    const goldPartHeight = mainBodyHeight / 3;
                    const termHeight = 8;
                    const termY = mainBodyY - termHeight;
                    const termWidth = cellWidth * 0.4;
                    const steelGrad = ctx.createLinearGradient(cellX - termWidth / 2, 0, cellX + termWidth / 2, 0);
                    steelGrad.addColorStop(0, '#B0C4DE'); steelGrad.addColorStop(0.5, '#FFFFFF'); steelGrad.addColorStop(1, '#B0C4DE');
                    ctx.save();
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)'; ctx.shadowBlur = 5; ctx.shadowOffsetX = 3; ctx.shadowOffsetY = 3;
                    ctx.fillStyle = steelGrad;
                    ctx.fillRect(cellX - termWidth / 2, termY, termWidth, termHeight);
                    ctx.strokeRect(cellX - termWidth / 2, termY, termWidth, termHeight);
                    ctx.restore();
                    const bodyGrad = ctx.createLinearGradient(cellX - cellWidth / 2, 0, cellX + cellWidth / 2, 0);
                    bodyGrad.addColorStop(0, 'black'); bodyGrad.addColorStop(0.5, '#696969'); bodyGrad.addColorStop(1, 'black');
                    ctx.save();
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)'; ctx.shadowBlur = 5; ctx.shadowOffsetX = 3; ctx.shadowOffsetY = 3;
                    ctx.fillStyle = bodyGrad;
                    ctx.fillRect(cellX - cellWidth / 2, mainBodyY, cellWidth, mainBodyHeight);
                    ctx.strokeRect(cellX - cellWidth / 2, mainBodyY, cellWidth, mainBodyHeight);
                    ctx.restore();
                    const goldGrad = ctx.createLinearGradient(cellX - cellWidth / 2, 0, cellX + cellWidth / 2, 0);
                    goldGrad.addColorStop(0, '#DAA520'); goldGrad.addColorStop(0.5, '#FFD700'); goldGrad.addColorStop(1, '#DAA520');
                    ctx.fillStyle = goldGrad;
                    ctx.fillRect(cellX - cellWidth / 2, mainBodyY, cellWidth, goldPartHeight);
                    ctx.strokeRect(cellX - cellWidth / 2, mainBodyY, cellWidth, goldPartHeight);
                    ctx.fillStyle = 'black'; ctx.font = '20px Arial';
                    ctx.fillText('+', cellX + 35, termY + 15);
                    ctx.fillText('-', cellX + 35, mainBodyY + mainBodyHeight);
                    posConnection = { x: cellX, y: termY };
                    negConnection = { x: cellX, y: mainBodyY + mainBodyHeight };
                } else if (selectedCellKey === 'car') {
                    const cellWidth = 120; const mainBodyHeight = 80; const bodyY = cellCenterY - mainBodyHeight / 2;
                    const bodyXStart = cellX - cellWidth / 2;
                    const bodyGrad = ctx.createLinearGradient(bodyXStart, 0, bodyXStart + cellWidth, 0);
                    bodyGrad.addColorStop(0, '#111111'); bodyGrad.addColorStop(0.1, '#444444'); bodyGrad.addColorStop(0.9, '#444444'); bodyGrad.addColorStop(1, '#111111');
                    ctx.fillStyle = bodyGrad;
                    ctx.save(); ctx.shadowColor = 'rgba(0, 0, 0, 0.5)'; ctx.shadowBlur = 5; ctx.shadowOffsetX = 3; ctx.shadowOffsetY = 3;
                    ctx.fillRect(cellX - cellWidth / 2, bodyY, cellWidth, mainBodyHeight);
                    ctx.restore();
                    ctx.strokeRect(cellX - cellWidth / 2, bodyY, cellWidth, mainBodyHeight);
                    const termWidth = 24; const termHeight = 15; const termY = bodyY - termHeight; const negTermX = cellX - 40; const posTermX = cellX + 40;
                    const negGrad = ctx.createLinearGradient(negTermX - termWidth / 2, 0, negTermX + termWidth / 2, 0);
                    negGrad.addColorStop(0, '#696969'); negGrad.addColorStop(0.5, '#A9A9A9'); negGrad.addColorStop(1, '#696969');
                    ctx.fillStyle = negGrad;
                    ctx.fillRect(negTermX - termWidth / 2, termY, termWidth, termHeight);
                    ctx.strokeRect(negTermX - termWidth / 2, termY, termWidth, termHeight);
                    const posGrad = ctx.createLinearGradient(posTermX - termWidth / 2, 0, posTermX + termWidth / 2, 0);
                    posGrad.addColorStop(0, '#D32F2F'); posGrad.addColorStop(0.5, '#FF8A8A'); posGrad.addColorStop(1, '#D32F2F');
                    ctx.fillStyle = posGrad;
                    ctx.fillRect(posTermX - termWidth / 2, termY, termWidth, termHeight);
                    ctx.strokeRect(posTermX - termWidth / 2, termY, termWidth, termHeight);
                    ctx.fillStyle = 'white'; ctx.font = 'bold 20px Arial';
                    ctx.fillText('+', posTermX, bodyY + 25);
                    ctx.fillText('-', negTermX, bodyY + 25);
                    posConnection = { x: posTermX, y: termY };
                    negConnection = { x: negTermX, y: termY };
                } else if (selectedCellKey === '9V') {
                    const cellWidth = 60; const mainBodyHeight = 90; const mainBodyY = cellCenterY - mainBodyHeight / 2; const topPartHeight = 30; const termHeight = 8;
                    const bodyXStart = cellX - cellWidth / 2;
                    const silverGrad = ctx.createLinearGradient(bodyXStart, 0, bodyXStart + cellWidth, 0);
                    silverGrad.addColorStop(0, '#707070'); silverGrad.addColorStop(4 / cellWidth, '#FAFAFA'); silverGrad.addColorStop((cellWidth - 4) / cellWidth, '#FAFAFA'); silverGrad.addColorStop(1, '#707070');
                    ctx.fillStyle = silverGrad;
                    ctx.save(); ctx.shadowColor = 'rgba(0, 0, 0, 0.5)'; ctx.shadowBlur = 5; ctx.shadowOffsetX = 3; ctx.shadowOffsetY = 3;
                    ctx.fillRect(cellX - cellWidth / 2, mainBodyY, cellWidth, mainBodyHeight);
                    ctx.restore();
                    ctx.strokeRect(cellX - cellWidth / 2, mainBodyY, cellWidth, mainBodyHeight);
                    const blackGrad = ctx.createLinearGradient(bodyXStart, 0, bodyXStart + cellWidth, 0);
                    blackGrad.addColorStop(0, '#000000'); blackGrad.addColorStop(4 / cellWidth, '#555555'); blackGrad.addColorStop((cellWidth - 4) / cellWidth, '#555555'); blackGrad.addColorStop(1, '#000000');
                    ctx.fillStyle = blackGrad;
                    ctx.fillRect(cellX - cellWidth / 2, mainBodyY, cellWidth, topPartHeight);
                    ctx.strokeRect(cellX - cellWidth / 2, mainBodyY, cellWidth, topPartHeight);
                    const terminalY = mainBodyY - termHeight; const negTermX = cellX - 18; const posTermX = cellX + 18;
                    ctx.fillStyle = '#DFDFDF'; ctx.strokeStyle = 'black'; ctx.lineWidth = 1;
                    const termWidth = cellWidth * 0.3;
                    const negSteelGrad = ctx.createLinearGradient(negTermX - termWidth / 2, 0, negTermX + termWidth / 2, 0);
                    negSteelGrad.addColorStop(0, '#B0C4DE'); negSteelGrad.addColorStop(0.5, '#FFFFFF'); negSteelGrad.addColorStop(1, '#B0C4DE');
                    ctx.save(); ctx.shadowColor = 'rgba(0, 0, 0, 0.5)'; ctx.shadowBlur = 5; ctx.shadowOffsetX = 3; ctx.shadowOffsetY = 3;
                    ctx.fillStyle = negSteelGrad;
                    ctx.fillRect(negTermX - termWidth / 2, terminalY, termWidth, termHeight);
                    ctx.strokeRect(negTermX - termWidth / 2, terminalY, termWidth, termHeight);
                    ctx.restore();
                    const posSteelGrad = ctx.createLinearGradient(posTermX - termWidth / 2, 0, posTermX + termWidth / 2, 0);
                    posSteelGrad.addColorStop(0, '#B0C4DE'); posSteelGrad.addColorStop(0.5, '#FFFFFF'); posSteelGrad.addColorStop(1, '#B0C4DE');
                    ctx.save(); ctx.shadowColor = 'rgba(0, 0, 0, 0.5)'; ctx.shadowBlur = 5; ctx.shadowOffsetX = 3; ctx.shadowOffsetY = 3;
                    ctx.fillStyle = posSteelGrad;
                    ctx.fillRect(posTermX - termWidth / 2, terminalY, termWidth, termHeight);
                    ctx.strokeRect(posTermX - termWidth / 2, terminalY, termWidth, termHeight);
                    ctx.restore();
                    ctx.fillStyle = 'black'; ctx.font = '20px Arial';
                    ctx.fillText('+', posTermX + 18, terminalY + 6); ctx.fillText('-', negTermX - 20, terminalY + 6);
                    posConnection = { x: posTermX, y: terminalY }; negConnection = { x: negTermX, y: terminalY };
                }
                ctx.font = '14px Arial';


                // --- Draw Decade Resistance Box (on bottom wire) ---
                const resRectX = resPos.x - 60;
                const resRectY = resPos.y - 25;
                const resRectWidth = 120;
                const resRectHeight = 50;
                
                // Main body
                const boxGrad = ctx.createLinearGradient(resRectX, resRectY, resRectX, resRectY + resRectHeight);
                boxGrad.addColorStop(0, '#606060');
                boxGrad.addColorStop(1, '#404040');
                ctx.fillStyle = boxGrad;
                ctx.save();
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)'; ctx.shadowBlur = 5; ctx.shadowOffsetX = 3; ctx.shadowOffsetY = 3;
                ctx.fillRect(resRectX, resRectY, resRectWidth, resRectHeight);
                ctx.restore();
                ctx.strokeRect(resRectX, resRectY, resRectWidth, resRectHeight);
                
                // Dials
                const numDials = 4;
                const dialRadius = 12;
                for (let i = 0; i < numDials; i++) {
                    const dialX = resRectX + (resRectWidth / (numDials + 1)) * (i + 1);
                    const dialY = resRectY + resRectHeight / 2;

                    // Dial background
                    ctx.beginPath();
                    ctx.arc(dialX, dialY, dialRadius, 0, 2 * Math.PI);
                    ctx.fillStyle = '#D0D0D0';
                    ctx.fill();
                    ctx.strokeStyle = '#303030';
                    ctx.stroke();

                    // Dial indicator line
                    const angle = (performance.now() / 500 + i * 2) % (2 * Math.PI); // Animate dials for visual effect
                    ctx.beginPath();
                    ctx.moveTo(dialX, dialY);
                    ctx.lineTo(dialX + Math.cos(angle) * (dialRadius - 2), dialY + Math.sin(angle) * (dialRadius - 2));
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.lineWidth = 2; // Reset
                }
                // Terminals
                ctx.fillStyle = 'red';
                ctx.beginPath(); ctx.arc(resRectX, resRectY + 10, 5, 0, 2 * Math.PI); ctx.fill();
                ctx.fillStyle = 'black';
                ctx.beginPath(); ctx.arc(resRectX + resRectWidth, resRectY + 10, 5, 0, 2 * Math.PI); ctx.fill();

                
                const { current } = calculateCircuitValues(loadResistance);
                lastCalculatedCurrent = current;

                // --- Draw Wires ---
                const ammeterWireY = ammeterPos.y + wireOffsetY;
                ctx.beginPath();
                // Positive terminal -> ammeter
                ctx.moveTo(posConnection.x, posConnection.y);
                ctx.lineTo(posConnection.x, ammeterWireY);
                ctx.lineTo(ammeterPos.x - meterWidth / 2, ammeterWireY);
                // Ammeter -> right side -> resistor box
                ctx.moveTo(ammeterPos.x + meterWidth / 2, ammeterWireY);
                ctx.lineTo(circuitRightX, ammeterWireY);
                ctx.lineTo(circuitRightX, resRectY + 10);
                ctx.lineTo(resRectX + resRectWidth, resRectY + 10);
                // Resistor box -> negative terminal
                ctx.moveTo(resRectX, resRectY + 10);
                ctx.lineTo(resRectX - 20, resRectY + 10);
                ctx.lineTo(resRectX - 20, bottomWireY);
                if (selectedCellKey === '9V' || selectedCellKey === 'car') {
                    const cellData = (selectedCellKey === '9V') ? { w: 60, y: 110 } : { w: 120, y: 115 };
                    const negWireX = cellX - (cellData.w / 2) - 20; 
                    const wireTopY = cellData.y;
                    ctx.lineTo(negWireX, bottomWireY); ctx.lineTo(negWireX, wireTopY); ctx.lineTo(negConnection.x, wireTopY); ctx.lineTo(negConnection.x, negConnection.y);
                } else {
                    ctx.lineTo(negConnection.x, bottomWireY); ctx.lineTo(negConnection.x, negConnection.y);
                }
                ctx.stroke();

                // --- Draw Ammeter (on top wire) ---
                ctx.save();
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)'; ctx.shadowBlur = 5; ctx.shadowOffsetX = 3; ctx.shadowOffsetY = 3;
                ctx.fillStyle = 'gold';
                roundRect(ctx, ammeterPos.x - meterWidth / 2, ammeterPos.y - meterHeight / 2, meterWidth, meterHeight, cornerRadius);
                ctx.fill();
                ctx.restore();
                ctx.stroke();
                ctx.fillStyle = 'black';
                ctx.fillRect(ammeterPos.x - meterWidth / 2, ammeterWireY - leadHeight / 2, leadWidth, leadHeight);
                ctx.fillRect(ammeterPos.x + meterWidth / 2 - leadWidth, ammeterWireY - leadHeight / 2, leadWidth, leadHeight);
                ctx.beginPath(); ctx.arc(ammeterPos.x - meterWidth / 2 + leadWidth, ammeterWireY, 3, 0, 2 * Math.PI); ctx.fill();
                ctx.beginPath(); ctx.arc(ammeterPos.x + meterWidth / 2 - leadWidth, ammeterWireY, 3, 0, 2 * Math.PI); ctx.fill();
                const lcdWidth = 56; const lcdHeight = 24; const lcdX = ammeterPos.x - lcdWidth / 2; const lcdY = ammeterPos.y - lcdHeight / 2;
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(lcdX, lcdY, lcdWidth, lcdHeight);
                ctx.strokeStyle = 'black'; ctx.lineWidth = 1; ctx.strokeRect(lcdX, lcdY, lcdWidth, lcdHeight); ctx.lineWidth = 2; ctx.strokeStyle = 'black';
                ctx.fillStyle = 'black';
                ctx.fillText('A', ammeterPos.x, ammeterPos.y - (meterHeight + lcdHeight) / 4 + 4);
                ctx.font = '12px "Courier New", monospace';
                ctx.textBaseline = 'middle';
                ctx.fillText(current.toFixed(2) + ' A', ammeterPos.x, ammeterPos.y);
                ctx.font = '14px Arial'; ctx.textBaseline = 'alphabetic';
            }

            // --- CALCULATIONS ---
            function calculateCircuitValues(loadResistance) {
                const totalResistance = internalResistance + loadResistance;
                let current = EMF / totalResistance; // This is the true, theoretical current

                if (uncertaintyToggle.checked) {
                    const uncertaintyFactor = (Math.random() - 0.5) * 0.1; // +/- 5% random error
                    current *= (1 + uncertaintyFactor); // Apply uncertainty to the current
                }
                return { current };
            }
            
            function calculateBestFit() {
                const validPoints = dataPoints.filter(p => p.meanCurrent !== null);
                if (validPoints.length < 2) return null;

                let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
                const n = validPoints.length;

                validPoints.forEach(p => {
                    const x = p.reciprocalCurrent;
                    const y = p.resistance;
                    sumX += x;
                    sumY += y;
                    sumXY += x * y;
                    sumX2 += x * x;
                });

                const gradient = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                const intercept = (sumY - gradient * sumX) / n;
                
                return { gradient, intercept };
            }

            // --- UPDATERS ---
            function updateTable() {
                dataTableBody.innerHTML = '';
                
                dataPoints.forEach(p => {
                    const i1 = p.currents[0] !== undefined ? p.currents[0].toFixed(2) : '-';
                    const i2 = p.currents[1] !== undefined ? p.currents[1].toFixed(2) : '-';
                    const i3 = p.currents[2] !== undefined ? p.currents[2].toFixed(2) : '-';
                    const mean = p.meanCurrent !== null ? p.meanCurrent.toFixed(2) : '-';
                    const uncertainty = p.uncertainty !== null ? p.uncertainty.toFixed(2) : '-';
                    const reciprocal = p.reciprocalCurrent !== null ? p.reciprocalCurrent.toFixed(3) : '-';

                    const row = `
                        <tr>
                            <td>${p.resistance.toFixed(2)}</td>
                            <td>${i1}</td>
                            <td>${i2}</td>
                            <td>${i3}</td>
                            <td><b>${mean}</b></td>
                            <td>${reciprocal}</td>
                            <td class="uncertainty-cell">${uncertainty}</td>
                        </tr>
                    `;
                    dataTableBody.innerHTML += row;
                });

                const emptyRowsNeeded = Math.max(0, 5 - dataPoints.length);
                for (let i = 0; i < emptyRowsNeeded; i++) {
                    const emptyRow = `<tr><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td class="uncertainty-cell">-</td></tr>`;
                    dataTableBody.innerHTML += emptyRow;
                }
            }
            
            function updateResults() {
                const fit = calculateBestFit();
                if (!fit) {
                    resultsOutput.innerHTML = '<p>Collect at least two data points to calculate the gradient and y-intercept.</p>';
                    return;
                }

                const gradient = fit.gradient;
                const intercept = fit.intercept;
                
                let katexString = `
                    <p>Using the equation $R = E(\\frac{1}{I}) - r$, we can determine the internal resistance and EMF from the graph.</p>
                `;
                
                if (chart && chart.gradientPoints) {
                    const { p1, p2 } = chart.gradientPoints;
                    katexString += `
                        <p><b>Gradient Calculation:</b></p>
                        <p>$$ m = \\frac{\\Delta R}{\\Delta (1/\\text{current})} = \\frac{${p2.y.toFixed(2)} - ${p1.y.toFixed(2)}}{${p2.x.toFixed(3)} - ${p1.x.toFixed(3)}} = ${gradient.toFixed(2)} $$</p>
                    `;
                }

                katexString += `
                    <p><b>Gradient (m) = ${gradient.toFixed(3)} V</b></p>
                    <p>Since $m = E$, the <b>EMF (E) = ${gradient.toFixed(3)} V</b></p>
                    <p><b>Y-Intercept (c) = ${intercept.toFixed(3)} Ω</b></p>
                    <p>Since $c = -r$, the <b>Internal Resistance (r) = ${(-intercept).toFixed(3)} Ω</b></p>
                `;

                resultsOutput.innerHTML = katexString;
                
                 if (window.renderMathInElement) {
                     renderMathInElement(resultsOutput, katexOptions);
                 }
            }

            function updateGraph() {
                const scatterData = dataPoints
                    .filter(p => p.meanCurrent !== null)
                    .map(p => ({ x: p.reciprocalCurrent, y: p.resistance }));
                
                chart.data.datasets[0].data = scatterData;

                const fit = calculateBestFit();

                if (fit) {
                    const xValues = scatterData.map(p => p.x).sort((a,b) => a - b);
                    if (xValues.length > 0) {
                        const minX = xValues[0];
                        const maxX = xValues[xValues.length - 1];
                        
                        const maxGraphX = chart.options.scales.x.max;
                        chart.data.datasets[1].data = [
                            { x: 0, y: fit.intercept },
                            { x: maxGraphX, y: fit.gradient * maxGraphX + fit.intercept }
                        ];

                        const scaleX = chart.scales.x;
                        const xTicks = scaleX.ticks.map(t => t.value).filter(t => t >= minX && t <= maxX);
                        
                        let p1 = { x: minX, y: fit.gradient * minX + fit.intercept };
                        let p2 = { x: maxX, y: fit.gradient * maxX + fit.intercept };
                        let maxDist = 0;

                        if (xTicks.length >= 2) {
                             for (let i = 0; i < xTicks.length; i++) {
                                 for (let j = i + 1; j < xTicks.length; j++) {
                                     const x1 = xTicks[i]; const x2 = xTicks[j];
                                     const y1 = fit.gradient * x1 + fit.intercept; const y2 = fit.gradient * x2 + fit.intercept;
                                     const dist = Math.hypot(x2 - x1, y2 - y1);
                                     if (dist > maxDist) {
                                         maxDist = dist; p1 = { x: x1, y: y1 }; p2 = { x: x2, y: y2 };
                                     }
                                 }
                             }
                        }
                        chart.gradientPoints = { p1, p2 };
                        chart.data.datasets[2].data = [ { x: p1.x, y: p1.y }, { x: p2.x, y: p1.y }, { x: p2.x, y: p2.y }];
                    }
                } else {
                     chart.data.datasets[1].data = []; chart.data.datasets[2].data = []; chart.gradientPoints = null;
                }
                chart.update();
            }

            function initChart() {
                const initialCell = cellTypes[cellTypeSelector.value];
                chart = new Chart(graphCtx, {
                    data: {
                        datasets: [
                            { type: 'scatter', label: 'Data Points', data: [], backgroundColor: 'rgba(176, 58, 46, 0.8)', borderColor: 'rgba(128, 0, 0, 1)' },
                            { type: 'line', label: 'Best-Fit Line', data: [], borderColor: 'rgba(0, 0, 0, 0.7)', borderWidth: 2, fill: false, pointRadius: 0 },
                            { type: 'line', label: 'Gradient Calculation', data: [], borderColor: 'rgba(0, 128, 0, 0.7)', borderWidth: 2, borderDash: [5, 5], fill: false, pointRadius: 0, showInLegend: false }
                        ]
                    },
                    options: {
                        maintainAspectRatio: false,
                        scales: {
                            x: { type: 'linear', position: 'bottom', title: { display: true, text: '1 / current (A⁻¹)' }, min: 0, max: initialCell.graphRecipIMax, ticks: { stepSize: initialCell.graphRecipIStep }, grid: { color: '#aaaaaa' }, border: { display: false } },
                            y: { 
                                title: { display: true, text: 'Load Resistance, R (Ω)' }, 
                                min: initialCell.graphRMin, 
                                max: initialCell.graphRMax, 
                                ticks: { stepSize: initialCell.graphRStep }, 
                                grid: {
                                    color: context => (context.tick.value === 0 ? 'rgba(0, 0, 0, 1)' : '#aaaaaa'),
                                    lineWidth: context => (context.tick.value === 0 ? 2 : 1)
                                }, 
                                border: { color: 'black', width: 2 } 
                            }
                        },
                        plugins: { 
                            tooltip: { callbacks: { label: function(context) { let label = context.dataset.label || ''; if (label) { label += ': '; } if (context.parsed.y !== null) { label += `(1/current: ${context.parsed.x.toFixed(3)} A⁻¹, R: ${context.parsed.y.toFixed(2)} Ω)`; } return label; } } },
                            legend: { filter: function(legendItem, chartData) { return chartData.datasets[legendItem.datasetIndex].data.length > 0; } }
                        }
                    }
                });
            }

            function resetData() {
                randomizeInternalResistance();
                dataPoints = [];
                updateTable();
                updateGraph();
                updateResults();
                drawScene(parseFloat(slider.value));
            }

            function updateCellPropertiesAndReset() {
                const selectedCellKey = cellTypeSelector.value;
                const cell = cellTypes[selectedCellKey];
                EMF = cell.emf;

                slider.min = cell.sliderMin; slider.max = cell.sliderMax; slider.step = cell.sliderStep;
                slider.value = (cell.sliderMin + cell.sliderMax) / 2;
                
                if (chart) {
                    chart.options.scales.x.max = cell.graphRecipIMax;
                    chart.options.scales.x.ticks.stepSize = cell.graphRecipIStep;
                    chart.options.scales.y.max = cell.graphRMax;
                    chart.options.scales.y.min = cell.graphRMin;
                    chart.options.scales.y.ticks.stepSize = cell.graphRStep;
                }
                
                resetData();
                
                const decimalPlaces = cell.sliderStep < 0.01 ? 3 : (cell.sliderStep < 0.1 ? 2 : 1);
                resistanceValueSpan.textContent = parseFloat(slider.value).toFixed(decimalPlaces);
                updateSliderFill();
            }

            // --- EVENT LISTENERS ---
            slider.addEventListener('input', () => {
                const resistance = parseFloat(slider.value);
                const selectedCellKey = cellTypeSelector.value;
                const cell = cellTypes[selectedCellKey];
                const decimalPlaces = cell.sliderStep < 0.01 ? 3 : (cell.sliderStep < 0.1 ? 2 : 1);
                resistanceValueSpan.textContent = resistance.toFixed(decimalPlaces);
                drawScene(resistance);
                updateSliderFill();
            });

            resetButton.addEventListener('click', resetData);
            uncertaintyToggle.addEventListener('change', resetData);
            cellTypeSelector.addEventListener('change', updateCellPropertiesAndReset);

            physicsDetails.addEventListener('toggle', () => {
                physicsDetails.parentElement.classList.toggle('is-open', physicsDetails.open);
                 if (physicsDetails.open) {
                    setTimeout(() => {
                        if (window.renderMathInElement) { renderMathInElement(physicsDetails, katexOptions); }
                    }, 400);
                }
            });

            measureButton.addEventListener('click', () => {
                if (lastCalculatedCurrent === null) return;
                
                const current = lastCalculatedCurrent;
                const R = parseFloat(slider.value);

                let existingPoint = dataPoints.find(p => p.resistance.toFixed(2) === R.toFixed(2));

                if (existingPoint) {
                    if (existingPoint.currents.length < 3) {
                        existingPoint.currents.push(current);
                    } else {
                        console.log("Maximum readings for this resistance value reached.");
                        return; 
                    }
                } else {
                    existingPoint = {
                        resistance: R,
                        currents: [current],
                        meanCurrent: null,
                        uncertainty: null,
                        reciprocalCurrent: null
                    };
                    dataPoints.push(existingPoint);
                }

                const sum = existingPoint.currents.reduce((a, b) => a + b, 0);
                existingPoint.meanCurrent = sum / existingPoint.currents.length;
                existingPoint.reciprocalCurrent = 1 / existingPoint.meanCurrent;
                
                if (existingPoint.currents.length > 1) {
                    const max = Math.max(...existingPoint.currents);
                    const min = Math.min(...existingPoint.currents);
                    existingPoint.uncertainty = (max - min) / existingPoint.currents.length;
                } else {
                    existingPoint.uncertainty = null;
                }
                
                dataPoints.sort((a, b) => a.resistance - b.resistance);

                updateTable();
                updateGraph();
                updateResults();
            });

            // --- INITIALIZATION CALL ---
            initChart();
            updateCellPropertiesAndReset();
        });
    </script>
</body>
</html>
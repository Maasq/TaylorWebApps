<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Steph Taylor">
    <meta name="version" content="1.01.03">

    <title>Internal Resistance of a Cell from a V vs I Graph</title>

    <!-- KaTeX for LaTeX rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" xintegrity="sha384-sCutvgpopvms1PSRPY+ax+sUpl1jsmm4w6+ERsYSJOiS2BZAoAx1+t1JdGjV3b85" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" xintegrity="sha384-hIoBPJpTadox55GCNM+PBOZpTmxH+SSt+HkexsB4rUIeGajGAXXfEaY9sm2RXP5L" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" xintegrity="sha384-43gviWU0YVjaDtb/Gf1I3Oths0VyDsAlpOvx8v2iIAMoZgKcrypMe7Au17VebouV" crossorigin="anonymous"></script>

    <!-- Chart.js for graphing -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        :root {
            --claret: #800000;
            --light-claret: #B03A2E;
            --darker-claret: #8a2e24;
            --amber: #FFBF00;
            --blush-pink: #F1D4D4;
            --pale-violet: #E6E6FA;
            --white: #FFFFFF;
            --black: #000000;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: var(--pale-violet);
            margin: 0;
            padding: 20px;
        }

        /* Header Styling */
        .header-container {
            background-color: var(--claret);
            border-radius: 10px;
            border: 2px solid var(--black);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            text-align: center;
            padding: 20px;
            margin-bottom: 20px;
            color: var(--white);
        }

        .header-title {
            color: var(--amber);
            font-weight: bold;
            font-size: 2em;
            margin: 0;
            font-family: Arial, sans-serif; /* Matched from Refractive Index Sim */
        }

        .header-subtitle {
            color: var(--blush-pink);
            font-size: 1.5em;
            margin: 0; /* Adjusted margin */
            font-family: Arial, sans-serif; /* Matched from Refractive Index Sim */
            font-weight: normal; /* Matched from Refractive Index Sim */
        }

        /* Layout Styling */
        .main-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            align-items: start;
        }

        @media (max-width: 1000px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Card Styling */
        .card {
            background-color: var(--white);
            border-radius: 10px;
            border: 2px solid var(--black);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            padding: 20px;
        }

        .card h3 {
            margin-top: 0;
            border-bottom: 2px solid var(--pale-violet);
            padding-bottom: 10px;
        }
        
        #experimentCanvas {
            display: block;
            margin: 0 auto;
            background-color: var(--white);
            border-radius: 5px;
        }

        /* Controls Styling */
        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
        }

        .slider-container {
            width: 80%;
            text-align: center;
        }

        .slider-container input[type="range"] {
            width: 100%;
        }

        /* Style the slider to match the button color */
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #ddd;
            border-radius: 5px;
            outline: none;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--light-claret);
            cursor: pointer;
            border-radius: 50%;
        }

        input[type=range]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--light-claret);
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
        
        .button-container {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }

        .measure-button {
            background-color: var(--light-claret);
            color: var(--white);
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .measure-button:hover {
            background-color: var(--darker-claret);
        }

        .reset-button {
            position: absolute;
            top: 29px;
            right: 20px;
            transform: translateY(-50%);
            background-color: var(--amber);
            color: var(--claret);
            font-weight: bold;
            border: 1px solid var(--claret);
            padding: 8px 16px;
            border-radius: 5px;
            font-size: 1.0em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .reset-button:hover {
            background-color: #e6ac00; /* Darker amber */
        }
        
        /* New Physics Card Styling */
        .physics-card {
            grid-column: 1 / -1;
            background-color: #FFFFE0; /* Light Yellow */
            padding: 5px 20px 10px;
            transition: background-color 0.4s ease-in-out;
        }

        .physics-card.is-open {
            background-color: var(--white);
        }

        .physics-card summary {
            cursor: pointer;
            font-weight: bold;
            list-style: none;
        }

        .physics-card summary::-webkit-details-marker {
            display: none;
        }

        .physics-card summary > h3 {
            text-align: center;
            border-bottom: none;
            padding-bottom: 0;
            margin-bottom: 0;
        }

        .physics-card.is-open summary > h3 {
            text-align: left;
            border-bottom: 2px solid var(--pale-violet);
            padding-bottom: 10px;
        }

        .physics-content {
            padding-top: 15px;
        }

        .physics-content p {
            line-height: 1.6;
        }

        /* Advanced Options (Collapsible) Styling */
        .advanced-options-card {
            background-color: #FFFFE0; /* Light Yellow from refractive index sim */
            padding: 5px 20px 10px; /* Made less tall */
        }

        .advanced-options-card h3 {
            border-bottom: none;
            padding-bottom: 0;
            margin-bottom: 0;
        }
        
        details > summary {
            cursor: pointer;
            font-weight: bold;
            list-style: none; /* Remove default marker */
            text-align: center; /* Centered the title */
        }

        details > summary::-webkit-details-marker {
            display: none; /* Remove default marker for Chrome/Safari */
        }

        .advanced-options-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
        }

        .toggle-switch {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        /* Toggle Switch Styling from refractive index sim */
        .switch { position: relative; display: inline-block; width: 60px; height: 34px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider-toggle { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider-toggle:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider-toggle { background-color: #800000; }
        input:checked + .slider-toggle:before { transform: translateX(26px); }


        /* Table Styling */
        .data-table-container {
            max-height: 400px;
            overflow-y: auto;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            text-align: center;
        }

        th, td {
            padding: 8px;
            border: 1px solid black;
        }

        thead th {
            background-color: var(--light-claret);
            color: var(--white);
            position: sticky;
            top: 0;
            z-index: 1;
        }

        /* Ensure sub-header background is also sticky */
        thead tr:nth-child(2) th {
            top: 36px; /* Height of the first header row */
        }
        
        .uncertainty-cell {
            background-color: #FADBD8; /* Light Red from Refractive Index Sim */
        }

        #graph-card {
            min-height: 400px;
            display: flex;
            flex-direction: column;
        }

        .graph-container {
            position: relative;
            flex-grow: 1;
        }

        .cell-selector-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .cell-selector-container select {
            padding: 5px;
            border-radius: 5px;
            border: 1px solid #ccc;
            font-size: 1em;
        }
    </style>
</head>
<body>

    <header class="header-container">
        <h1 class="header-title">Strathaven Academy Physics Department</h1>
        <h2 class="header-subtitle">Finding the Internal Resistance of a Cell Using a V vs I Graph</h2>
    </header>

    <div class="main-layout">
        <!-- Background Physics Card -->
        <div class="card physics-card">
            <details id="physicsDetails">
                <summary><h3>Background Physics</h3></summary>
                <div class="physics-content">
                    <h4>Electromotive Force (EMF)</h4>
                    <p>The <strong>electromotive force (EMF)</strong> of a source, denoted by the symbol $E$, is the total energy supplied to each coulomb of charge as it passes through the source. It is the voltage you would measure across the cell's terminals when no current is flowing (i.e., in an open circuit).</p>
                    
                    <h4>Ideal vs. Real Cells & Lost Volts</h4>
                    <p>An <strong>ideal cell</strong> would provide its full EMF across its terminals no matter how much current was drawn from it. However, in a <strong>real cell</strong>, the chemical processes that generate the voltage are not perfectly efficient. As current flows, some energy is converted to heat within the cell. This energy, per coulomb of charge, that is "lost" as heat is known as the <strong>"lost volts"</strong> ($V_{lost}$).</p>
                    
                    <h4>Internal Resistance</h4>
                    <p>This energy loss means a real source behaves as if it contains a perfect EMF source ($E$) connected in series with a small resistor. We call this conceptual resistor the <strong>internal resistance ($r$)</strong> of the cell.</p>

                    <div style="text-align: center; margin: 20px 0;">
                        <img src="internal resistance a1.webp" alt="Circuit diagram showing a real power source model" style="max-width: 400px;">
                        <p style="font-size: 0.9em; color: #555; margin-top: 5px;">A real power source can be modelled as an ideal EMF ($E$) in series with an internal resistance ($r$).</p>
                    </div>

                    <h4>Terminal Potential Difference and the Governing Equation</h4>
                    <p>The actual voltage available to the external circuit is called the <strong>terminal potential difference ($V$)</strong>. This is the EMF minus the volts that were "lost" inside the cell.
                    $$ E = V + V_{lost} $$
                    Since the lost volts are the potential difference across the internal resistance, we can use Ohm's Law ($V=IR$) to state: $V_{lost} = I \times r$. Therefore, the governing equation for the circuit is:
                    $$ E = V + Ir $$
                    </p>

                    <h4>Determining E and r Graphically</h4>
                    <p>To find the internal resistance and the true EMF, we can rearrange the equation to match quantities we can easily measure: the terminal PD ($V$) and the current ($I$). Making $V$ the subject of the formula gives:</p>
                    $$ V = -Ir + E $$
                    <p>This equation is in the form of a straight line, <strong>$y = mx + c$</strong>, where:</p>
                    <ul>
                        <li>$y$ corresponds to the Terminal PD, $V$.</li>
                        <li>$x$ corresponds to the Current, $I$.</li>
                        <li>The <strong>gradient ($m$)</strong> corresponds to the <strong>negative internal resistance ($-r$)</strong>.</li>
                        <li>The <strong>y-intercept ($c$)</strong> corresponds to the <strong>EMF ($E$)</strong>.</li>
                    </ul>
                    <p>By measuring several pairs of values for $V$ and $I$ as you vary the external load, you can plot a graph of $V$ against $I$. The y-intercept gives you the EMF, and the negative of the gradient gives the internal resistance.</p>
                    <div style="text-align: center; margin: 20px 0;">
                        <img src="internal resistance a2.webp" alt="Graph of Terminal PD vs Current showing EMF and gradient" style="max-width: 400px;">
                        <p style="font-size: 0.9em; color: #555; margin-top: 5px;">The graph of V vs I is a straight line. The y-intercept is the EMF ($E$) and the gradient is the negative internal resistance ($-r$).</p>
                    </div>
                </div>
            </details>
        </div>

        <!-- Left Panel -->
        <div class="panel">
            <div class="card" style="position: relative;">
                <button id="resetButton" class="reset-button">Reset</button>
                <h3>Experiment Setup</h3>
                <div class="cell-selector-container">
                    <label for="cellTypeSelector">Type of cell:</label>
                    <select id="cellTypeSelector">
                        <option value="D">D Cell</option>
                        <option value="car">Car Battery</option>
                        <option value="9V">9 V Cell</option>
                    </select>
                </div>
                <canvas id="experimentCanvas" width="600" height="350"></canvas>
                <div class="controls">
                    <div class="slider-container">
                        <label for="resistanceSlider">Load Resistance, R = <span id="resistanceValue">1.0</span> Ω</label>
                        <input type="range" id="resistanceSlider" min="0.1" max="2.0" step="0.01" value="1.0">
                    </div>
                    <div class="button-container">
                        <button id="measureButton" class="measure-button">Take Readings</button>
                    </div>
                </div>
            </div>

            <div class="card advanced-options-card">
                <details>
                    <summary><h3>Advanced Options</h3></summary>
                    <div class="advanced-options-controls">
                        <div class="toggle-switch">
                            <label for="uncertaintyToggle">Enable Random Uncertainty:</label>
                            <label class="switch">
                                <input type="checkbox" id="uncertaintyToggle">
                                <span class="slider-toggle"></span>
                            </label>
                        </div>
                    </div>
                </details>
            </div>

            <div class="card">
                <h3>Results</h3>
                <div id="resultsOutput">
                    <p>Collect at least two data points to calculate the gradient.</p>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="panel">
            <div class="card">
                <h3>Results Table</h3>
                <div class="data-table-container">
                    <table>
                        <thead>
                            <tr>
                                <th rowspan="2">Current (A)</th>
                                <th colspan="4">Terminal Potential Difference (V)</th>
                                <th rowspan="2">Random Uncertainty<br>in PD (V)</th>
                            </tr>
                            <tr>
                                <th>V₁</th>
                                <th>V₂</th>
                                <th>V₃</th>
                                <th>Mean, V̄</th>
                            </tr>
                        </thead>
                        <tbody id="dataTableBody">
                            <!-- Data rows will be inserted here -->
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="card" id="graph-card">
                <h3>Graph of Terminal PD vs. Current</h3>
                <div class="graph-container">
                    <canvas id="resultsGraph"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const katexOptions = {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false},
                    {left: '\\(', right: '\\)', display: false},
                    {left: '\\[', right: '\\]', display: true}
                ],
                throwOnError : false
            };
            
             if (window.renderMathInElement) {
                 renderMathInElement(document.body, katexOptions);
             }

            // --- DOM ELEMENTS ---
            const canvas = document.getElementById('experimentCanvas');
            const ctx = canvas.getContext('2d');
            const slider = document.getElementById('resistanceSlider');
            const resistanceValueSpan = document.getElementById('resistanceValue');
            const measureButton = document.getElementById('measureButton');
            const resetButton = document.getElementById('resetButton');
            const uncertaintyToggle = document.getElementById('uncertaintyToggle');
            const dataTableBody = document.getElementById('dataTableBody');
            const resultsOutput = document.getElementById('resultsOutput');
            const graphCtx = document.getElementById('resultsGraph').getContext('2d');
            const physicsDetails = document.getElementById('physicsDetails');
            const cellTypeSelector = document.getElementById('cellTypeSelector');

            // --- CONSTANTS & STATE ---
            const cellTypes = {
                'D':   { name: 'D Cell',      emf: 1.5,  minR: 0.20, maxR: 0.35,  sliderMin: 0.1,   sliderMax: 2.0,   sliderStep: 0.01,  graphIMax: 5.5,  graphVMax: 1.6,  graphIStep: 0.5,  graphVStep: 0.2 },
                'car': { name: 'Car Battery', emf: 12.6, minR: 0.01, maxR: 0.03,  sliderMin: 0.01,  sliderMax: 0.1,   sliderStep: 0.001, graphIMax: 650,  graphVMax: 13.0, graphIStep: 50,  graphVStep: 1   },
                '9V':  { name: '9 V Cell',    emf: 9.0,  minR: 1.0,  maxR: 2.5,   sliderMin: 2.0,   sliderMax: 10.0,  sliderStep: 0.1,   graphIMax: 3.0,  graphVMax: 10.0, graphIStep: 0.2, graphVStep: 1   }
            };
            let EMF; // Volts - will be set by cell type
            let internalResistance; // Ohms - will be randomized
            let dataPoints = [];
            let chart;
            let lastCalculatedCurrent = null;
            let lastCalculatedTerminalPD = null;

            function randomizeInternalResistance() {
                const selectedCellKey = cellTypeSelector.value;
                const cell = cellTypes[selectedCellKey];
                const min = cell.minR;
                const max = cell.maxR;
                const randomValue = Math.random() * (max - min) + min;
                internalResistance = parseFloat(randomValue.toFixed(cell.sliderStep < 0.01 ? 3 : 2));
            }


            // --- SLIDER FILL ---
            function updateSliderFill() {
                const percentage = ((slider.value - slider.min) / (slider.max - slider.min)) * 100;
                slider.style.background = `linear-gradient(to right, var(--light-claret) ${percentage}%, #ddd ${percentage}%)`;
            }

            // --- CANVAS DRAWING ---
            function roundRect(ctx, x, y, width, height, radius) {
              if (width < 2 * radius) radius = width / 2;
              if (height < 2 * radius) radius = height / 2;
              ctx.beginPath();
              ctx.moveTo(x + radius, y);
              ctx.arcTo(x + width, y, x + width, y + height, radius);
              ctx.arcTo(x + width, y + height, x, y + height, radius);
              ctx.arcTo(x, y + height, x, y, radius);
              ctx.arcTo(x, y, x + width, y, radius);
              ctx.closePath();
            }

            function drawScene(loadResistance) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'black';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';

                const horizontalOffset = 100;
                
                // --- Component positions ---
                const cellX = 100 + horizontalOffset;
                const circuitRightX = 400 + horizontalOffset; // X-coordinate for the right side of the circuit
                const topWireY = 75;
                const bottomWireY = 300;
                
                // Center components on their respective wires
                const ammeterPos = { x: (cellX + circuitRightX) / 2, y: topWireY };
                const resPos = { x: (cellX + circuitRightX) / 2, y: bottomWireY };
                const voltmeterPos = { x: resPos.x, y: 220 }; // Place voltmeter above the resistor

                // --- Draw Cell Type Label ---
                const selectedCellKey = cellTypeSelector.value;
                const cell = cellTypes[selectedCellKey];
                const cellCenterY = (topWireY + bottomWireY) / 2;
                ctx.save();
                ctx.fillStyle = 'black';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(cell.name, 70, cellCenterY);
                ctx.restore();


                const leadConnectYOffset = 28; // Y-offset from meter center to connection point
                const leadWidth = 10;
                const leadHeight = 2;
                const meterWidth = 70;
                const meterHeight = 60;
                const cornerRadius = 5;
                const wireOffsetY = 20;

                // --- Draw Cell ---
                // Vertically center the cell relative to the circuit wires
                const cellWidth = 40;
                const mainBodyHeight = 90;
                //const cellCenterY = (topWireY + bottomWireY) / 2; // already defined for label
                const mainBodyY = cellCenterY - mainBodyHeight / 2;
                const goldPartHeight = mainBodyHeight / 3;
                const termHeight = 8;
                const termY = mainBodyY - termHeight; // Y-coord of the top terminal nub

                // 1. Positive Terminal (Steel gradient)
                const termWidth = cellWidth * 0.5;
                const steelGrad = ctx.createLinearGradient(cellX - termWidth / 2, 0, cellX + termWidth / 2, 0);
                steelGrad.addColorStop(0, '#B0C4DE'); // LightSteelBlue
                steelGrad.addColorStop(0.5, '#FFFFFF');
                steelGrad.addColorStop(1, '#B0C4DE');
                ctx.save();
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;
                ctx.fillStyle = steelGrad;
                ctx.fillRect(cellX - termWidth / 2, termY, termWidth, termHeight);
                ctx.restore();
                ctx.strokeRect(cellX - termWidth / 2, termY, termWidth, termHeight);
                
                // 2. Main Body (Black/Grey gradient)
                const bodyGrad = ctx.createLinearGradient(cellX - cellWidth / 2, 0, cellX + cellWidth / 2, 0);
                bodyGrad.addColorStop(0, 'black');
                bodyGrad.addColorStop(0.5, '#696969'); // Dark Grey
                bodyGrad.addColorStop(1, 'black');
                ctx.save();
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;

                ctx.fillStyle = bodyGrad;
                ctx.fillRect(cellX - cellWidth / 2, mainBodyY, cellWidth, mainBodyHeight);
                ctx.restore();
                ctx.strokeRect(cellX - cellWidth / 2, mainBodyY, cellWidth, mainBodyHeight);

                // 3. Gold Top Part
                const goldGrad = ctx.createLinearGradient(cellX - cellWidth / 2, 0, cellX + cellWidth / 2, 0);
                goldGrad.addColorStop(0, '#DAA520'); // GoldenRod
                goldGrad.addColorStop(0.5, '#FFD700'); // Gold
                goldGrad.addColorStop(1, '#DAA520');
                ctx.fillStyle = goldGrad;
                ctx.fillRect(cellX - cellWidth / 2, mainBodyY, cellWidth, goldPartHeight);
                ctx.strokeRect(cellX - cellWidth / 2, mainBodyY, cellWidth, goldPartHeight);

                // Cell Labels
                ctx.fillStyle = 'black';
                ctx.font = '20px Arial';
                // Adjust label position to be next to the physical terminals
                ctx.fillText('+', cellX + 35, termY + 15);
                ctx.fillText('-', cellX + 35, mainBodyY + mainBodyHeight);
                ctx.font = '14px Arial';


                // --- Draw Wires ---
                const ammeterWireY = ammeterPos.y + wireOffsetY;
                ctx.beginPath();
                // From positive terminal, up to top wire, then across (stopping for ammeter)
                ctx.moveTo(cellX, termY);
                ctx.lineTo(cellX, ammeterWireY);
                ctx.lineTo(ammeterPos.x - meterWidth / 2, ammeterWireY);

                // From ammeter, across to right side, then down
                ctx.moveTo(ammeterPos.x + meterWidth / 2, ammeterWireY);
                ctx.lineTo(circuitRightX, ammeterWireY);
                ctx.lineTo(circuitRightX, bottomWireY);
                
                // Across bottom wire (stopping for resistor)
                ctx.lineTo(resPos.x + 40, bottomWireY);

                // From resistor, across to left side, then up to negative terminal
                ctx.moveTo(resPos.x - 40, bottomWireY);
                ctx.lineTo(cellX, bottomWireY);
                ctx.lineTo(cellX, mainBodyY + mainBodyHeight);
                ctx.stroke();

                // --- Draw Variable Resistor (on bottom wire) ---
                const resRectX = resPos.x - 40;
                const resRectY = resPos.y - 15;
                const resRectWidth = 80;
                const resRectHeight = 30;
                
                // Main body of the resistor
                ctx.fillStyle = '#B0B0B0'; // Darker grey background
                ctx.fillRect(resRectX, resRectY, resRectWidth, resRectHeight);
                ctx.strokeRect(resRectX, resRectY, resRectWidth, resRectHeight);
                
                // Fill with vertical lines
                ctx.save();
                ctx.strokeStyle = '#808080'; // Grey stripes
                ctx.lineWidth = 1.5;
                for (let i = 5; i < resRectWidth; i += 5) {
                    ctx.beginPath();
                    ctx.moveTo(resRectX + i, resRectY);
                    ctx.lineTo(resRectX + i, resRectY + resRectHeight);
                    ctx.stroke();
                }
                ctx.restore();

                // --- Draw Selector on Resistor ---
                const sliderMin = parseFloat(slider.min);
                const sliderMax = parseFloat(slider.max);
                const sliderRange = sliderMax - sliderMin;
                const valueInRange = loadResistance - sliderMin;
                const percentage = valueInRange / sliderRange;

                const selectorWidth = 18;
                const selectorHeight = 10;
                
                // Calculate the position of the left edge of the selector
                const selectorLeftX = resRectX + (percentage * (resRectWidth - selectorWidth));

                // Black top rectangle
                const selectorTopY = resRectY - selectorHeight;
                ctx.fillStyle = 'black';
                ctx.fillRect(selectorLeftX, selectorTopY, selectorWidth, selectorHeight);

                // Copper-colored contact rectangle hanging down
                const contactWidth = 6;
                const contactHeight = 12; // How far it hangs down
                const contactX = selectorLeftX + (selectorWidth - contactWidth) / 2;
                const contactY = selectorTopY + selectorHeight; // Starts at the bottom of the black rect
                const copperGrad = ctx.createLinearGradient(contactX, contactY, contactX + contactWidth, contactY);
                copperGrad.addColorStop(0, '#b87333'); // Darker copper
                copperGrad.addColorStop(0.5, '#f5deb3'); // Lighter wheat/copper highlight
                copperGrad.addColorStop(1, '#b87333'); // Darker copper
                ctx.fillStyle = copperGrad;
                ctx.fillRect(contactX, contactY, contactWidth, contactHeight);


                const { current, terminalPD } = calculateCircuitValues(loadResistance);
                lastCalculatedCurrent = current;
                lastCalculatedTerminalPD = terminalPD;

                // --- Draw Ammeter (on top wire) ---
                // Body
                ctx.save();
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;

                ctx.fillStyle = 'gold';
                roundRect(ctx, ammeterPos.x - meterWidth / 2, ammeterPos.y - meterHeight / 2, meterWidth, meterHeight, cornerRadius);
                ctx.fill();
                ctx.restore();
                ctx.stroke();
                // Draw ammeter leads
                ctx.fillStyle = 'black';
                ctx.fillRect(ammeterPos.x - meterWidth / 2, ammeterWireY - leadHeight / 2, leadWidth, leadHeight);
                ctx.fillRect(ammeterPos.x + meterWidth / 2 - leadWidth, ammeterWireY - leadHeight / 2, leadWidth, leadHeight);

                // Connection dots
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(ammeterPos.x - meterWidth / 2 + leadWidth, ammeterWireY, 3, 0, 2 * Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(ammeterPos.x + meterWidth / 2 - leadWidth, ammeterWireY, 3, 0, 2 * Math.PI);
                ctx.fill();

                // LCD Screen
                const lcdWidth = 56;
                const lcdHeight = 24;
                const lcdX = ammeterPos.x - lcdWidth / 2;
                const lcdY = ammeterPos.y - lcdHeight / 2;
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(lcdX, lcdY, lcdWidth, lcdHeight);
                ctx.strokeStyle = 'black'; // Thin black border
                ctx.lineWidth = 1;
                ctx.strokeRect(lcdX, lcdY, lcdWidth, lcdHeight);
                ctx.lineWidth = 2; // Reset for other components
                ctx.strokeStyle = 'black';

                // Text
                ctx.fillStyle = 'black';
                ctx.fillText('A', ammeterPos.x, ammeterPos.y - (meterHeight + lcdHeight) / 4 + 4);
                ctx.font = '12px "Courier New", monospace';
                ctx.textBaseline = 'middle'; // Vertically center text
                ctx.fillText(current.toFixed(2) + ' A', ammeterPos.x, ammeterPos.y);
                ctx.font = '14px Arial';
                ctx.textBaseline = 'alphabetic'; // Reset baseline

                // --- Draw Voltmeter ---
                // Body
                ctx.save();
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;

                ctx.fillStyle = 'gold';
                roundRect(ctx, voltmeterPos.x - meterWidth / 2, voltmeterPos.y - meterHeight / 2, meterWidth, meterHeight, cornerRadius);
                ctx.fill();
                ctx.restore();
                ctx.stroke();

                // Draw voltmeter leads
                const voltmeterWireY = voltmeterPos.y + wireOffsetY;
                ctx.fillStyle = 'black';
                ctx.fillRect(voltmeterPos.x - meterWidth / 2, voltmeterWireY - leadHeight / 2, leadWidth, leadHeight);
                ctx.fillRect(voltmeterPos.x + meterWidth / 2 - leadWidth, voltmeterWireY - leadHeight / 2, leadWidth, leadHeight);
                
                // Connection dots
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(voltmeterPos.x - meterWidth / 2 + leadWidth, voltmeterWireY, 3, 0, 2 * Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(voltmeterPos.x + meterWidth / 2 - leadWidth, voltmeterWireY, 3, 0, 2 * Math.PI);
                ctx.fill();

                // LCD Screen
                ctx.fillStyle = '#f0f0f0';
                const vLcdX = voltmeterPos.x - lcdWidth / 2;
                const vLcdY = voltmeterPos.y - lcdHeight / 2;
                ctx.fillRect(vLcdX, vLcdY, lcdWidth, lcdHeight);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1;
                ctx.strokeRect(vLcdX, vLcdY, lcdWidth, lcdHeight);
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'black';
                
                // Text
                ctx.fillStyle = 'black';
                ctx.fillText('V', voltmeterPos.x, voltmeterPos.y - (meterHeight + lcdHeight) / 4 + 4);
                ctx.font = '12px "Courier New", monospace';
                ctx.textBaseline = 'middle';
                ctx.fillText(terminalPD.toFixed(2) + ' V', voltmeterPos.x, voltmeterPos.y);
                ctx.font = '14px Arial';
                ctx.textBaseline = 'alphabetic'; // Reset

                // --- Connect voltmeter in parallel to the resistor ---
                const junctionLeftX = resPos.x - 60;
                const junctionRightX = resPos.x + 60;
            
                // Wires
                ctx.beginPath();
                // Left connection from bottom wire up to voltmeter's connection point
                ctx.moveTo(junctionLeftX, bottomWireY);
                ctx.lineTo(junctionLeftX, voltmeterWireY);
                ctx.lineTo(voltmeterPos.x - meterWidth / 2, voltmeterWireY);
            
                // Right connection from bottom wire up to voltmeter's connection point
                ctx.moveTo(junctionRightX, bottomWireY);
                ctx.lineTo(junctionRightX, voltmeterWireY);
                ctx.lineTo(voltmeterPos.x + meterWidth / 2, voltmeterWireY);
                ctx.stroke();
            
                // Dots
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(junctionLeftX, bottomWireY, 3, 0, 2 * Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(junctionRightX, bottomWireY, 3, 0, 2 * Math.PI);
                ctx.fill();
            }

            // --- CALCULATIONS ---
            function calculateCircuitValues(loadResistance) {
                const totalResistance = internalResistance + loadResistance;
                const current = EMF / totalResistance; // This is the true, theoretical current
                let terminalPD = current * loadResistance; // This is the true, theoretical PD

                if (uncertaintyToggle.checked) {
                    const uncertaintyFactor = (Math.random() - 0.5) * 0.1; // +/- 5% random error
                    terminalPD *= (1 + uncertaintyFactor); // Apply uncertainty ONLY to the PD
                }

                return { current, terminalPD }; // Return true current and potentially uncertain PD
            }
            
            function calculateBestFit() {
                const validPoints = dataPoints.filter(p => p.meanPD !== null);
                if (validPoints.length < 2) return null;

                let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
                const n = validPoints.length;

                validPoints.forEach(p => {
                    const x = p.current;
                    const y = p.meanPD;
                    sumX += x;
                    sumY += y;
                    sumXY += x * y;
                    sumX2 += x * x;
                });

                const gradient = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                const intercept = (sumY - gradient * sumX) / n;
                
                return { gradient, intercept };
            }

            // --- UPDATERS ---
            function updateTable() {
                dataTableBody.innerHTML = '';
                
                dataPoints.forEach(p => {
                    const v1 = p.pds[0] !== undefined ? p.pds[0].toFixed(2) : '-';
                    const v2 = p.pds[1] !== undefined ? p.pds[1].toFixed(2) : '-';
                    const v3 = p.pds[2] !== undefined ? p.pds[2].toFixed(2) : '-';
                    const mean = p.meanPD !== null ? p.meanPD.toFixed(2) : '-';
                    const uncertainty = p.uncertainty !== null ? p.uncertainty.toFixed(2) : '-';

                    const row = `
                        <tr>
                            <td>${p.current.toFixed(2)}</td>
                            <td>${v1}</td>
                            <td>${v2}</td>
                            <td>${v3}</td>
                            <td><b>${mean}</b></td>
                            <td class="uncertainty-cell">${uncertainty}</td>
                        </tr>
                    `;
                    dataTableBody.innerHTML += row;
                });

                const emptyRowsNeeded = Math.max(0, 5 - dataPoints.length);
                for (let i = 0; i < emptyRowsNeeded; i++) {
                    const emptyRow = `<tr><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td class="uncertainty-cell">-</td></tr>`;
                    dataTableBody.innerHTML += emptyRow;
                }
            }
            
            function updateResults() {
                const fit = calculateBestFit();
                if (!fit) {
                    resultsOutput.innerHTML = '<p>Collect at least two data points to calculate the gradient and y-intercept.</p>';
                    return;
                }

                const gradient = fit.gradient;
                const intercept = fit.intercept;
                
                let katexString = `
                    <p>Using the equation $V = E - Ir$, we can determine the internal resistance and EMF from the graph.</p>
                `;
                
                if (chart && chart.gradientPoints) {
                    const { p1, p2 } = chart.gradientPoints;
                    katexString += `
                        <p><b>Gradient Calculation:</b></p>
                        <p>$$ m = \\frac{\\Delta V}{\\Delta I} = \\frac{${p2.y.toFixed(2)} - ${p1.y.toFixed(2)}}{${p2.x.toFixed(2)} - ${p1.x.toFixed(2)}} = ${gradient.toFixed(2)} $$</p>
                    `;
                }

                katexString += `
                    <p><b>Gradient (m) = ${gradient.toFixed(3)} V/A</b></p>
                    <p>Since $m = -r$, the <b>Internal Resistance (r) = ${(-gradient).toFixed(3)} Ω</b></p>
                    <p><b>Y-Intercept (c) = ${intercept.toFixed(3)} V</b></p>
                    <p>Since $c = E$, the <b>EMF (E) = ${intercept.toFixed(3)} V</b></p>
                `;

                resultsOutput.innerHTML = katexString;
                
                 if (window.renderMathInElement) {
                     renderMathInElement(resultsOutput, katexOptions);
                 }
            }

            function updateGraph() {
                const scatterData = dataPoints
                    .filter(p => p.meanPD !== null)
                    .map(p => ({ x: p.current, y: p.meanPD }));
                
                chart.data.datasets[0].data = scatterData;

                const fit = calculateBestFit();

                if (fit) {
                    const xValues = scatterData.map(p => p.x).sort((a,b) => a - b);
                    if (xValues.length > 0) {
                        const minX = xValues[0]; // For triangle calculation
                        const maxX = xValues[xValues.length - 1]; // For triangle calculation
                        
                        // Extrapolate the best-fit line to the edges of the graph
                        const maxGraphX = chart.options.scales.x.max;
                        chart.data.datasets[1].data = [
                            { x: 0, y: fit.intercept },
                            { x: maxGraphX, y: fit.gradient * maxGraphX + fit.intercept }
                        ];

                        // Logic for gradient triangle
                        const scaleX = chart.scales.x;
                        const xTicks = scaleX.ticks.map(t => t.value).filter(t => t >= minX && t <= maxX);
                        
                        let p1 = { x: minX, y: fit.gradient * minX + fit.intercept };
                        let p2 = { x: maxX, y: fit.gradient * maxX + fit.intercept };
                        let maxDist = 0;

                        if (xTicks.length >= 2) {
                             for (let i = 0; i < xTicks.length; i++) {
                                 for (let j = i + 1; j < xTicks.length; j++) {
                                     const x1 = xTicks[i];
                                     const x2 = xTicks[j];
                                     const y1 = fit.gradient * x1 + fit.intercept;
                                     const y2 = fit.gradient * x2 + fit.intercept;
                                     
                                     const dist = Math.hypot(x2 - x1, y2 - y1);
                                     if (dist > maxDist) {
                                         maxDist = dist;
                                         p1 = { x: x1, y: y1 };
                                         p2 = { x: x2, y: y2 };
                                     }
                                 }
                             }
                        }

                        chart.gradientPoints = { p1, p2 };
                        
                        chart.data.datasets[2].data = [
                            { x: p1.x, y: p1.y },
                            { x: p2.x, y: p1.y },
                            { x: p2.x, y: p2.y }
                        ];
                    }
                } else {
                     chart.data.datasets[1].data = [];
                     chart.data.datasets[2].data = [];
                     chart.gradientPoints = null;
                }
                
                chart.update();
            }

            function initChart() {
                const initialCell = cellTypes[cellTypeSelector.value];
                chart = new Chart(graphCtx, {
                    data: {
                        datasets: [
                            { type: 'scatter', label: 'Data Points', data: [], backgroundColor: 'rgba(176, 58, 46, 0.8)', borderColor: 'rgba(128, 0, 0, 1)' },
                            { type: 'line', label: 'Best-Fit Line', data: [], borderColor: 'rgba(0, 0, 0, 0.7)', borderWidth: 2, fill: false, pointRadius: 0 },
                            {
                                type: 'line',
                                label: 'Gradient Calculation',
                                data: [],
                                borderColor: 'rgba(0, 128, 0, 0.7)',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                fill: false,
                                pointRadius: 0,
                                showInLegend: false
                            }
                        ]
                    },
                    options: {
                        maintainAspectRatio: false,
                        scales: {
                            x: { type: 'linear', position: 'bottom', title: { display: true, text: 'Current (A)' }, min: 0, max: initialCell.graphIMax, ticks: { stepSize: initialCell.graphIStep }, grid: { color: '#aaaaaa' }, border: { color: 'black', width: 2 } },
                            y: { title: { display: true, text: 'Terminal PD (V)' }, min: 0, max: initialCell.graphVMax, ticks: { stepSize: initialCell.graphVStep }, grid: { color: '#aaaaaa' }, border: { color: 'black', width: 2 } }
                        },
                        plugins: { 
                            tooltip: { callbacks: { label: function(context) { let label = context.dataset.label || ''; if (label) { label += ': '; } if (context.parsed.y !== null) { label += `(I: ${context.parsed.x.toFixed(2)} A, V: ${context.parsed.y.toFixed(2)} V)`; } return label; } } },
                            legend: {
                                filter: function(legendItem, chartData) {
                                    // Only show the legend item if its corresponding dataset has data.
                                    return chartData.datasets[legendItem.datasetIndex].data.length > 0;
                                }
                            }
                        }
                    }
                });
            }

            function resetData() {
                randomizeInternalResistance();
                dataPoints = [];
                updateTable();
                updateGraph();
                updateResults();
                drawScene(parseFloat(slider.value)); // Redraw meters
            }

            function updateCellPropertiesAndReset() {
                const selectedCellKey = cellTypeSelector.value;
                const cell = cellTypes[selectedCellKey];
                EMF = cell.emf;

                // Update slider attributes
                slider.min = cell.sliderMin;
                slider.max = cell.sliderMax;
                slider.step = cell.sliderStep;
                slider.value = (cell.sliderMin + cell.sliderMax) / 2;
                
                // Update graph axes
                if (chart) {
                    chart.options.scales.x.max = cell.graphIMax;
                    chart.options.scales.x.ticks.stepSize = cell.graphIStep;
                    chart.options.scales.y.max = cell.graphVMax;
                    chart.options.scales.y.ticks.stepSize = cell.graphVStep;
                    chart.update();
                }
                
                resetData();
                
                // Update slider text and fill AFTER resetData has set the slider value
                const decimalPlaces = cell.sliderStep < 0.01 ? 3 : (cell.sliderStep < 0.1 ? 2 : 1);
                resistanceValueSpan.textContent = parseFloat(slider.value).toFixed(decimalPlaces);
                updateSliderFill();
            }

            // --- EVENT LISTENERS ---
            slider.addEventListener('input', () => {
                const resistance = parseFloat(slider.value);
                const selectedCellKey = cellTypeSelector.value;
                const cell = cellTypes[selectedCellKey];
                const decimalPlaces = cell.sliderStep < 0.01 ? 3 : (cell.sliderStep < 0.1 ? 2 : 1);
                resistanceValueSpan.textContent = resistance.toFixed(decimalPlaces);
                drawScene(resistance);
                updateSliderFill();
            });

            resetButton.addEventListener('click', resetData);
            uncertaintyToggle.addEventListener('change', resetData);
            cellTypeSelector.addEventListener('change', updateCellPropertiesAndReset);

            physicsDetails.addEventListener('toggle', () => {
                physicsDetails.parentElement.classList.toggle('is-open', physicsDetails.open);
                 if (physicsDetails.open) {
                    // KaTeX may need a moment to reflow, re-render after transition
                    setTimeout(() => {
                        if (window.renderMathInElement) {
                            renderMathInElement(physicsDetails, katexOptions);
                        }
                    }, 400); // Should be same as transition time
                }
            });

            measureButton.addEventListener('click', () => {
                if (lastCalculatedCurrent === null || lastCalculatedTerminalPD === null) return;
                
                const current = lastCalculatedCurrent;
                const terminalPD = lastCalculatedTerminalPD;
                const R = parseFloat(slider.value);

                // Find if a point with a similar *current* already exists.
                let existingPoint = dataPoints.find(p => p.current.toFixed(2) === current.toFixed(2));

                if (existingPoint) {
                    // This is a repeat reading for an existing current value
                    if (existingPoint.pds.length < 3) {
                        existingPoint.pds.push(terminalPD);
                    } else {
                        console.log("Maximum readings for this current value reached.");
                        return; 
                    }
                } else {
                    // This is a new data point for a new current value
                    existingPoint = {
                        resistance: R, // It's still good to know what resistance caused this current
                        current: current, // The nominal current is the identifier for this data series
                        pds: [terminalPD], // Start the list of measured PDs with the current one
                        meanPD: null,
                        uncertainty: null
                    };
                    dataPoints.push(existingPoint);
                }

                const sum = existingPoint.pds.reduce((a, b) => a + b, 0);
                existingPoint.meanPD = sum / existingPoint.pds.length;
                
                if (existingPoint.pds.length > 1) {
                    const max = Math.max(...existingPoint.pds);
                    const min = Math.min(...existingPoint.pds);
                    existingPoint.uncertainty = (max - min) / existingPoint.pds.length;
                } else {
                    existingPoint.uncertainty = null;
                }
                
                dataPoints.sort((a, b) => a.current - b.current); // Sort by current ascending

                updateTable();
                updateGraph();
                updateResults();
            });

            // --- INITIALIZATION CALL ---
            initChart();
            updateCellPropertiesAndReset();
        });
    </script>
</body>
</html>


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Steph Taylor">
    <meta name="version" content="00.08.01">

    <title>Internal Resistance of a Cell from a V vs I Graph</title>

    <!-- KaTeX for LaTeX rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" xintegrity="sha384-sCutvgpopvms1PSRPY+ax+sUpl1jsmm4w6+ERsYSJOiS2BZAoAx1+t1JdGjV3b85" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" xintegrity="sha384-hIoBPJpTadox55GCNM+PBOZpTmxH+SSt+HkexsB4rUIeGajGAXXfEaY9sm2RXP5L" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" xintegrity="sha384-43gviWU0YVjaDtb/Gf1I3Oths0VyDsAlpOvx8v2iIAMoZgKcrypMe7Au17VebouV" crossorigin="anonymous"></script>

    <!-- Chart.js for graphing -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        :root {
            --claret: #800000;
            --light-claret: #B03A2E;
            --darker-claret: #8a2e24;
            --amber: #FFBF00;
            --blush-pink: #F1D4D4;
            --pale-violet: #E6E6FA;
            --white: #FFFFFF;
            --black: #000000;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: var(--pale-violet);
            margin: 0;
            padding: 20px;
        }

        /* Header Styling */
        .header-container {
            background-color: var(--claret);
            border-radius: 10px;
            border: 2px solid var(--black);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            text-align: center;
            padding: 20px;
            margin-bottom: 20px;
            color: var(--white);
        }

        .header-title {
            color: var(--amber);
            font-weight: bold;
            font-size: 2em;
            margin: 0;
            font-family: Arial, sans-serif; /* Matched from Refractive Index Sim */
        }

        .header-subtitle {
            color: var(--blush-pink);
            font-size: 1.5em;
            margin: 0; /* Adjusted margin */
            font-family: Arial, sans-serif; /* Matched from Refractive Index Sim */
            font-weight: normal; /* Matched from Refractive Index Sim */
        }

        /* Layout Styling */
        .main-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            align-items: start;
        }

        @media (max-width: 1000px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Card Styling */
        .card {
            background-color: var(--white);
            border-radius: 10px;
            border: 2px solid var(--black);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            padding: 20px;
        }

        .card h3 {
            margin-top: 0;
            border-bottom: 2px solid var(--pale-violet);
            padding-bottom: 10px;
        }
        
        #experimentCanvas {
            display: block;
            margin: 0 auto;
            background-color: var(--white);
            border-radius: 5px;
        }

        /* Controls Styling */
        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
        }

        .slider-container {
            width: 80%;
            text-align: center;
        }

        .slider-container input[type="range"] {
            width: 100%;
        }

        /* Style the slider to match the button color */
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #ddd;
            border-radius: 5px;
            outline: none;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--light-claret);
            cursor: pointer;
            border-radius: 50%;
        }

        input[type=range]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--light-claret);
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
        
        .button-container {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }

        .measure-button {
            background-color: var(--light-claret);
            color: var(--white);
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .measure-button:hover {
            background-color: var(--darker-claret);
        }

        .reset-button {
            position: absolute;
            top: 29px;
            right: 20px;
            transform: translateY(-50%);
            background-color: var(--amber);
            color: var(--claret);
            font-weight: bold;
            border: 1px solid var(--claret);
            padding: 8px 16px;
            border-radius: 5px;
            font-size: 1.0em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .reset-button:hover {
            background-color: #e6ac00; /* Darker amber */
        }
        
        /* New Physics Card Styling */
        .physics-card {
            grid-column: 1 / -1;
            background-color: #FFFFE0; /* Light Yellow */
            padding: 5px 20px 10px;
            transition: background-color 0.4s ease-in-out;
        }

        .physics-card.is-open {
            background-color: var(--white);
        }

        .physics-card summary {
            cursor: pointer;
            font-weight: bold;
            list-style: none;
        }

        .physics-card summary::-webkit-details-marker {
            display: none;
        }

        .physics-card summary > h3 {
            text-align: center;
            border-bottom: none;
            padding-bottom: 0;
            margin-bottom: 0;
        }

        .physics-card.is-open summary > h3 {
            text-align: left;
            border-bottom: 2px solid var(--pale-violet);
            padding-bottom: 10px;
        }

        .physics-content {
            padding-top: 15px;
        }

        .physics-content p {
            line-height: 1.6;
        }

        /* Advanced Options (Collapsible) Styling */
        .advanced-options-card {
            background-color: #FFFFE0; /* Light Yellow from refractive index sim */
            padding: 5px 20px 10px; /* Made less tall */
        }

        .advanced-options-card h3 {
            border-bottom: none;
            padding-bottom: 0;
            margin-bottom: 0;
        }
        
        details > summary {
            cursor: pointer;
            font-weight: bold;
            list-style: none; /* Remove default marker */
            text-align: center; /* Centered the title */
        }

        details > summary::-webkit-details-marker {
            display: none; /* Remove default marker for Chrome/Safari */
        }

        .advanced-options-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
        }

        .toggle-switch {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        /* Toggle Switch Styling from refractive index sim */
        .switch { position: relative; display: inline-block; width: 60px; height: 34px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider-toggle { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider-toggle:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider-toggle { background-color: #800000; }
        input:checked + .slider-toggle:before { transform: translateX(26px); }


        /* Table Styling */
        .data-table-container {
            max-height: 400px;
            overflow-y: auto;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            text-align: center;
        }

        th, td {
            padding: 8px;
            border: 1px solid black;
        }

        thead th {
            background-color: var(--light-claret);
            color: var(--white);
            position: sticky;
            top: 0;
            z-index: 1;
        }

        /* Ensure sub-header background is also sticky */
        thead tr:nth-child(2) th {
            top: 36px; /* Height of the first header row */
        }
        
        .uncertainty-cell {
            background-color: #FADBD8; /* Light Red from Refractive Index Sim */
        }

        #graph-card {
            min-height: 400px;
            display: flex;
            flex-direction: column;
        }

        .graph-container {
            position: relative;
            flex-grow: 1;
        }
    </style>
</head>
<body>

    <header class="header-container">
        <h1 class="header-title">Strathaven Academy Physics Department</h1>
        <h2 class="header-subtitle">Finding the Internal Resistance of a Cell Using a V vs I Graph</h2>
    </header>

    <div class="main-layout">
        <!-- Background Physics Card -->
        <div class="card physics-card">
            <details id="physicsDetails">
                <summary><h3>Background Physics</h3></summary>
                <div class="physics-content">
                    <p>The electromotive force (EMF, denoted by $\epsilon$) of a power source like a battery is the total energy supplied per unit of charge. However, not all of this energy is available to the external circuit. The materials within the battery have their own resistance, known as internal resistance (denoted by $r$).</p>
                    <p>When a current ($I$) flows from the battery, some potential difference is "lost" across this internal resistance. This lost voltage is equal to $Ir$. The potential difference that is actually available to the external circuit is called the terminal potential difference ($V$).</p>
                    <p>The relationship between these quantities is given by the equation:</p>
                    $$ V = \epsilon - Ir $$
                    <p>This equation is in the form of a straight line, $y = mx + c$. By plotting a graph of the terminal potential difference ($V$) on the y-axis against the current ($I$) on the x-axis:</p>
                    <ul>
                        <li>The <b>gradient ($m$)</b> of the graph will be equal to the <b>negative internal resistance ($-r$)</b>.</li>
                        <li>The <b>y-intercept ($c$)</b> of the graph will be equal to the <b>EMF ($\epsilon$)</b> of the cell.</li>
                    </ul>
                    <p>In this experiment, you will vary the external load resistance ($R$) to change the current ($I$) flowing in the circuit and measure the corresponding terminal potential difference ($V$). By plotting these values, you can determine the internal resistance and EMF of the simulated cell.</p>
                </div>
            </details>
        </div>

        <!-- Left Panel -->
        <div class="panel">
            <div class="card" style="position: relative;">
                <button id="resetButton" class="reset-button">Reset</button>
                <h3>Experiment Setup</h3>
                <canvas id="experimentCanvas" width="600" height="350"></canvas>
                <div class="controls">
                    <div class="slider-container">
                        <label for="resistanceSlider">Load Resistance, R = <span id="resistanceValue">1.0</span> Ω</label>
                        <input type="range" id="resistanceSlider" min="0.1" max="2.0" step="0.01" value="1.0">
                    </div>
                    <div class="button-container">
                        <button id="measureButton" class="measure-button">Take Readings</button>
                    </div>
                </div>
            </div>

            <div class="card advanced-options-card">
                <details>
                    <summary><h3>Advanced Options</h3></summary>
                    <div class="advanced-options-controls">
                        <div class="toggle-switch">
                            <label for="uncertaintyToggle">Enable Random Uncertainty:</label>
                            <label class="switch">
                                <input type="checkbox" id="uncertaintyToggle">
                                <span class="slider-toggle"></span>
                            </label>
                        </div>
                    </div>
                </details>
            </div>

            <div class="card">
                <h3>Results</h3>
                <div id="resultsOutput">
                    <p>Collect at least two data points to calculate the gradient.</p>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="panel">
            <div class="card">
                <h3>Results Table</h3>
                <div class="data-table-container">
                    <table>
                        <thead>
                            <tr>
                                <th rowspan="2">Current (A)</th>
                                <th colspan="4">Terminal Potential Difference (V)</th>
                                <th rowspan="2">Random Uncertainty<br>in PD (V)</th>
                            </tr>
                            <tr>
                                <th>V₁</th>
                                <th>V₂</th>
                                <th>V₃</th>
                                <th>Mean, V̄</th>
                            </tr>
                        </thead>
                        <tbody id="dataTableBody">
                            <!-- Data rows will be inserted here -->
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="card" id="graph-card">
                <h3>Graph of Terminal PD vs. Current</h3>
                <div class="graph-container">
                    <canvas id="resultsGraph"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const katexOptions = {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false},
                    {left: '\\(', right: '\\)', display: false},
                    {left: '\\[', right: '\\]', display: true}
                ],
                throwOnError : false
            };
            
             if (window.renderMathInElement) {
                 renderMathInElement(document.body, katexOptions);
             }

            // --- DOM ELEMENTS ---
            const canvas = document.getElementById('experimentCanvas');
            const ctx = canvas.getContext('2d');
            const slider = document.getElementById('resistanceSlider');
            const resistanceValueSpan = document.getElementById('resistanceValue');
            const measureButton = document.getElementById('measureButton');
            const resetButton = document.getElementById('resetButton');
            const uncertaintyToggle = document.getElementById('uncertaintyToggle');
            const dataTableBody = document.getElementById('dataTableBody');
            const resultsOutput = document.getElementById('resultsOutput');
            const graphCtx = document.getElementById('resultsGraph').getContext('2d');
            const physicsDetails = document.getElementById('physicsDetails');

            // --- CONSTANTS & STATE ---
            const EMF = 1.5; // Volts
            let internalResistance; // Ohms - will be randomized
            let dataPoints = [];
            let chart;
            let lastCalculatedCurrent = null;
            let lastCalculatedTerminalPD = null;

            function randomizeInternalResistance() {
                const min = 0.20;
                const max = 0.35;
                const randomValue = Math.random() * (max - min) + min;
                internalResistance = parseFloat(randomValue.toFixed(2));
            }


            // --- SLIDER FILL ---
            function updateSliderFill() {
                const percentage = ((slider.value - slider.min) / (slider.max - slider.min)) * 100;
                slider.style.background = `linear-gradient(to right, var(--light-claret) ${percentage}%, #ddd ${percentage}%)`;
            }

            // --- CANVAS DRAWING ---
            function roundRect(ctx, x, y, width, height, radius) {
              if (width < 2 * radius) radius = width / 2;
              if (height < 2 * radius) radius = height / 2;
              ctx.beginPath();
              ctx.moveTo(x + radius, y);
              ctx.arcTo(x + width, y, x + width, y + height, radius);
              ctx.arcTo(x + width, y + height, x, y + height, radius);
              ctx.arcTo(x, y + height, x, y, radius);
              ctx.arcTo(x, y, x + width, y, radius);
              ctx.closePath();
            }

            function drawScene(loadResistance) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'black';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';

                
                // --- Component positions ---
                const cellX = 100;
                const circuitRightX = 400; // X-coordinate for the right side of the circuit
                const topWireY = 75;
                const bottomWireY = 300;
                
                // Center components on their respective wires
                const ammeterPos = { x: (cellX + circuitRightX) / 2, y: topWireY };
                const resPos = { x: (cellX + circuitRightX) / 2, y: bottomWireY };
                const voltmeterPos = { x: resPos.x, y: 220 }; // Place voltmeter above the resistor

                const leadConnectYOffset = 28; // Y-offset from meter center to connection point
                const leadWidth = 10;
                const leadHeight = 2;
                const meterWidth = 70;
                const meterHeight = 60;
                const cornerRadius = 5;
                const wireOffsetY = 20;

                // --- Draw Cell ---
                // Vertically center the cell relative to the circuit wires
                const cellWidth = 40;
                const mainBodyHeight = 90;
                const cellCenterY = (topWireY + bottomWireY) / 2;
                const mainBodyY = cellCenterY - mainBodyHeight / 2;
                const goldPartHeight = mainBodyHeight / 3;
                const termHeight = 8;
                const termY = mainBodyY - termHeight; // Y-coord of the top terminal nub

                // 1. Positive Terminal (Steel gradient)
                const termWidth = cellWidth * 0.5;
                const steelGrad = ctx.createLinearGradient(cellX - termWidth / 2, 0, cellX + termWidth / 2, 0);
                steelGrad.addColorStop(0, '#B0C4DE'); // LightSteelBlue
                steelGrad.addColorStop(0.5, '#FFFFFF');
                steelGrad.addColorStop(1, '#B0C4DE');
                ctx.save();
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;
                ctx.fillStyle = steelGrad;
                ctx.fillRect(cellX - termWidth / 2, termY, termWidth, termHeight);
                ctx.restore();
                ctx.strokeRect(cellX - termWidth / 2, termY, termWidth, termHeight);
                
                // 2. Main Body (Black/Grey gradient)
                const bodyGrad = ctx.createLinearGradient(cellX - cellWidth / 2, 0, cellX + cellWidth / 2, 0);
                bodyGrad.addColorStop(0, 'black');
                bodyGrad.addColorStop(0.5, '#696969'); // Dark Grey
                bodyGrad.addColorStop(1, 'black');
                ctx.save();
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;

                ctx.fillStyle = bodyGrad;
                ctx.fillRect(cellX - cellWidth / 2, mainBodyY, cellWidth, mainBodyHeight);
                ctx.restore();
                ctx.strokeRect(cellX - cellWidth / 2, mainBodyY, cellWidth, mainBodyHeight);

                // 3. Gold Top Part
                const goldGrad = ctx.createLinearGradient(cellX - cellWidth / 2, 0, cellX + cellWidth / 2, 0);
                goldGrad.addColorStop(0, '#DAA520'); // GoldenRod
                goldGrad.addColorStop(0.5, '#FFD700'); // Gold
                goldGrad.addColorStop(1, '#DAA520');
                ctx.fillStyle = goldGrad;
                ctx.fillRect(cellX - cellWidth / 2, mainBodyY, cellWidth, goldPartHeight);
                ctx.strokeRect(cellX - cellWidth / 2, mainBodyY, cellWidth, goldPartHeight);

                // Cell Labels
                ctx.fillStyle = 'black';
                ctx.font = '20px Arial';
                // Adjust label position to be next to the physical terminals
                ctx.fillText('+', cellX + 35, termY + 15);
                ctx.fillText('-', cellX + 35, mainBodyY + mainBodyHeight);
                ctx.font = '14px Arial';


                // --- Draw Wires ---
                const ammeterWireY = ammeterPos.y + wireOffsetY;
                ctx.beginPath();
                // From positive terminal, up to top wire, then across (stopping for ammeter)
                ctx.moveTo(cellX, termY);
                ctx.lineTo(cellX, ammeterWireY);
                ctx.lineTo(ammeterPos.x - meterWidth / 2, ammeterWireY);

                // From ammeter, across to right side, then down
                ctx.moveTo(ammeterPos.x + meterWidth / 2, ammeterWireY);
                ctx.lineTo(circuitRightX, ammeterWireY);
                ctx.lineTo(circuitRightX, bottomWireY);
                
                // Across bottom wire (stopping for resistor)
                ctx.lineTo(resPos.x + 40, bottomWireY);

                // From resistor, across to left side, then up to negative terminal
                ctx.moveTo(resPos.x - 40, bottomWireY);
                ctx.lineTo(cellX, bottomWireY);
                ctx.lineTo(cellX, mainBodyY + mainBodyHeight);
                ctx.stroke();

                // --- Draw Variable Resistor (on bottom wire) ---
                const resRectX = resPos.x - 40;
                const resRectY = resPos.y - 15;
                const resRectWidth = 80;
                const resRectHeight = 30;
                
                // Main body of the resistor
                ctx.fillStyle = '#B0B0B0'; // Darker grey background
                ctx.fillRect(resRectX, resRectY, resRectWidth, resRectHeight);
                ctx.strokeRect(resRectX, resRectY, resRectWidth, resRectHeight);
                
                // Fill with vertical lines
                ctx.save();
                ctx.strokeStyle = '#808080'; // Grey stripes
                ctx.lineWidth = 1.5;
                for (let i = 5; i < resRectWidth; i += 5) {
                    ctx.beginPath();
                    ctx.moveTo(resRectX + i, resRectY);
                    ctx.lineTo(resRectX + i, resRectY + resRectHeight);
                    ctx.stroke();
                }
                ctx.restore();

                // --- Draw Selector on Resistor ---
                const sliderMin = parseFloat(slider.min);
                const sliderMax = parseFloat(slider.max);
                const sliderRange = sliderMax - sliderMin;
                const valueInRange = loadResistance - sliderMin;
                const percentage = valueInRange / sliderRange;

                const selectorWidth = 18;
                const selectorHeight = 10;
                
                // Calculate the position of the left edge of the selector
                const selectorLeftX = resRectX + (percentage * (resRectWidth - selectorWidth));

                // Black top rectangle
                const selectorTopY = resRectY - selectorHeight;
                ctx.fillStyle = 'black';
                ctx.fillRect(selectorLeftX, selectorTopY, selectorWidth, selectorHeight);

                // Copper-colored contact rectangle hanging down
                const contactWidth = 6;
                const contactHeight = 12; // How far it hangs down
                const contactX = selectorLeftX + (selectorWidth - contactWidth) / 2;
                const contactY = selectorTopY + selectorHeight; // Starts at the bottom of the black rect
                const copperGrad = ctx.createLinearGradient(contactX, contactY, contactX + contactWidth, contactY);
                copperGrad.addColorStop(0, '#b87333'); // Darker copper
                copperGrad.addColorStop(0.5, '#f5deb3'); // Lighter wheat/copper highlight
                copperGrad.addColorStop(1, '#b87333'); // Darker copper
                ctx.fillStyle = copperGrad;
                ctx.fillRect(contactX, contactY, contactWidth, contactHeight);


                const { current, terminalPD } = calculateCircuitValues(loadResistance);
                lastCalculatedCurrent = current;
                lastCalculatedTerminalPD = terminalPD;

                // --- Draw Ammeter (on top wire) ---
                // Body
                ctx.save();
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;

                ctx.fillStyle = 'gold';
                roundRect(ctx, ammeterPos.x - meterWidth / 2, ammeterPos.y - meterHeight / 2, meterWidth, meterHeight, cornerRadius);
                ctx.fill();
                ctx.restore();
                ctx.stroke();
                // Draw ammeter leads
                ctx.fillStyle = 'black';
                ctx.fillRect(ammeterPos.x - meterWidth / 2, ammeterWireY - leadHeight / 2, leadWidth, leadHeight);
                ctx.fillRect(ammeterPos.x + meterWidth / 2 - leadWidth, ammeterWireY - leadHeight / 2, leadWidth, leadHeight);

                // Connection dots
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(ammeterPos.x - meterWidth / 2 + leadWidth, ammeterWireY, 3, 0, 2 * Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(ammeterPos.x + meterWidth / 2 - leadWidth, ammeterWireY, 3, 0, 2 * Math.PI);
                ctx.fill();

                // LCD Screen
                const lcdWidth = 56;
                const lcdHeight = 24;
                const lcdX = ammeterPos.x - lcdWidth / 2;
                const lcdY = ammeterPos.y - lcdHeight / 2;
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(lcdX, lcdY, lcdWidth, lcdHeight);
                ctx.strokeStyle = 'black'; // Thin black border
                ctx.lineWidth = 1;
                ctx.strokeRect(lcdX, lcdY, lcdWidth, lcdHeight);
                ctx.lineWidth = 2; // Reset for other components
                ctx.strokeStyle = 'black';

                // Text
                ctx.fillStyle = 'black';
                ctx.fillText('A', ammeterPos.x, ammeterPos.y - (meterHeight + lcdHeight) / 4 + 4);
                ctx.font = '12px "Courier New", monospace';
                ctx.textBaseline = 'middle'; // Vertically center text
                ctx.fillText(current.toFixed(2) + ' A', ammeterPos.x, ammeterPos.y);
                ctx.font = '14px Arial';
                ctx.textBaseline = 'alphabetic'; // Reset baseline

                // --- Draw Voltmeter ---
                // Body
                ctx.save();
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;

                ctx.fillStyle = 'gold';
                roundRect(ctx, voltmeterPos.x - meterWidth / 2, voltmeterPos.y - meterHeight / 2, meterWidth, meterHeight, cornerRadius);
                ctx.fill();
                ctx.restore();
                ctx.stroke();

                // Draw voltmeter leads
                const voltmeterWireY = voltmeterPos.y + wireOffsetY;
                ctx.fillStyle = 'black';
                ctx.fillRect(voltmeterPos.x - meterWidth / 2, voltmeterWireY - leadHeight / 2, leadWidth, leadHeight);
                ctx.fillRect(voltmeterPos.x + meterWidth / 2 - leadWidth, voltmeterWireY - leadHeight / 2, leadWidth, leadHeight);
                
                // Connection dots
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(voltmeterPos.x - meterWidth / 2 + leadWidth, voltmeterWireY, 3, 0, 2 * Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(voltmeterPos.x + meterWidth / 2 - leadWidth, voltmeterWireY, 3, 0, 2 * Math.PI);
                ctx.fill();

                // LCD Screen
                ctx.fillStyle = '#f0f0f0';
                const vLcdX = voltmeterPos.x - lcdWidth / 2;
                const vLcdY = voltmeterPos.y - lcdHeight / 2;
                ctx.fillRect(vLcdX, vLcdY, lcdWidth, lcdHeight);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1;
                ctx.strokeRect(vLcdX, vLcdY, lcdWidth, lcdHeight);
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'black';
                
                // Text
                ctx.fillStyle = 'black';
                ctx.fillText('V', voltmeterPos.x, voltmeterPos.y - (meterHeight + lcdHeight) / 4 + 4);
                ctx.font = '12px "Courier New", monospace';
                ctx.textBaseline = 'middle';
                ctx.fillText(terminalPD.toFixed(2) + ' V', voltmeterPos.x, voltmeterPos.y);
                ctx.font = '14px Arial';
                ctx.textBaseline = 'alphabetic'; // Reset

                // --- Connect voltmeter in parallel to the resistor ---
                const junctionLeftX = resPos.x - 60;
                const junctionRightX = resPos.x + 60;
            
                // Wires
                ctx.beginPath();
                // Left connection from bottom wire up to voltmeter's connection point
                ctx.moveTo(junctionLeftX, bottomWireY);
                ctx.lineTo(junctionLeftX, voltmeterWireY);
                ctx.lineTo(voltmeterPos.x - meterWidth / 2, voltmeterWireY);
            
                // Right connection from bottom wire up to voltmeter's connection point
                ctx.moveTo(junctionRightX, bottomWireY);
                ctx.lineTo(junctionRightX, voltmeterWireY);
                ctx.lineTo(voltmeterPos.x + meterWidth / 2, voltmeterWireY);
                ctx.stroke();
            
                // Dots
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(junctionLeftX, bottomWireY, 3, 0, 2 * Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(junctionRightX, bottomWireY, 3, 0, 2 * Math.PI);
                ctx.fill();
            }

            // --- CALCULATIONS ---
            function calculateCircuitValues(loadResistance) {
                const totalResistance = internalResistance + loadResistance;
                const current = EMF / totalResistance; // This is the true, theoretical current
                let terminalPD = current * loadResistance; // This is the true, theoretical PD

                if (uncertaintyToggle.checked) {
                    const uncertaintyFactor = (Math.random() - 0.5) * 0.1; // +/- 5% random error
                    terminalPD *= (1 + uncertaintyFactor); // Apply uncertainty ONLY to the PD
                }

                return { current, terminalPD }; // Return true current and potentially uncertain PD
            }
            
            function calculateBestFit() {
                const validPoints = dataPoints.filter(p => p.meanPD !== null);
                if (validPoints.length < 2) return null;

                let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
                const n = validPoints.length;

                validPoints.forEach(p => {
                    const x = p.current;
                    const y = p.meanPD;
                    sumX += x;
                    sumY += y;
                    sumXY += x * y;
                    sumX2 += x * x;
                });

                const gradient = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                const intercept = (sumY - gradient * sumX) / n;
                
                return { gradient, intercept };
            }

            // --- UPDATERS ---
            function updateTable() {
                dataTableBody.innerHTML = '';
                
                dataPoints.forEach(p => {
                    const v1 = p.pds[0] !== undefined ? p.pds[0].toFixed(2) : '-';
                    const v2 = p.pds[1] !== undefined ? p.pds[1].toFixed(2) : '-';
                    const v3 = p.pds[2] !== undefined ? p.pds[2].toFixed(2) : '-';
                    const mean = p.meanPD !== null ? p.meanPD.toFixed(2) : '-';
                    const uncertainty = p.uncertainty !== null ? p.uncertainty.toFixed(2) : '-';

                    const row = `
                        <tr>
                            <td>${p.current.toFixed(2)}</td>
                            <td>${v1}</td>
                            <td>${v2}</td>
                            <td>${v3}</td>
                            <td><b>${mean}</b></td>
                            <td class="uncertainty-cell">${uncertainty}</td>
                        </tr>
                    `;
                    dataTableBody.innerHTML += row;
                });

                const emptyRowsNeeded = Math.max(0, 5 - dataPoints.length);
                for (let i = 0; i < emptyRowsNeeded; i++) {
                    const emptyRow = `<tr><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td class="uncertainty-cell">-</td></tr>`;
                    dataTableBody.innerHTML += emptyRow;
                }
            }
            
            function updateResults() {
                const fit = calculateBestFit();
                if (!fit) {
                    resultsOutput.innerHTML = '<p>Collect at least two data points to calculate the gradient and y-intercept.</p>';
                    return;
                }

                const gradient = fit.gradient;
                const intercept = fit.intercept;
                
                let katexString = `
                    <p>Using the equation $V = \\epsilon - Ir$, we can determine the internal resistance and EMF from the graph.</p>
                `;
                
                if (chart && chart.gradientPoints) {
                    const { p1, p2 } = chart.gradientPoints;
                    katexString += `
                        <p><b>Gradient Calculation:</b></p>
                        <p>$$ m = \\frac{\\Delta V}{\\Delta I} = \\frac{${p2.y.toFixed(2)} - ${p1.y.toFixed(2)}}{${p2.x.toFixed(2)} - ${p1.x.toFixed(2)}} = ${gradient.toFixed(2)} $$</p>
                    `;
                }

                katexString += `
                    <p><b>Gradient (m) = ${gradient.toFixed(3)} V/A</b></p>
                    <p>Since $m = -r$, the <b>Internal Resistance (r) = ${(-gradient).toFixed(3)} Ω</b></p>
                    <p><b>Y-Intercept (c) = ${intercept.toFixed(3)} V</b></p>
                    <p>Since $c = \\epsilon$, the <b>EMF (ε) = ${intercept.toFixed(3)} V</b></p>
                `;

                resultsOutput.innerHTML = katexString;
                
                 if (window.renderMathInElement) {
                     renderMathInElement(resultsOutput, katexOptions);
                 }
            }

            function updateGraph() {
                const scatterData = dataPoints
                    .filter(p => p.meanPD !== null)
                    .map(p => ({ x: p.current, y: p.meanPD }));
                
                chart.data.datasets[0].data = scatterData;

                const fit = calculateBestFit();

                if (fit) {
                    const xValues = scatterData.map(p => p.x).sort((a,b) => a - b);
                    if (xValues.length > 0) {
                        const minX = xValues[0]; // For triangle calculation
                        const maxX = xValues[xValues.length - 1]; // For triangle calculation
                        
                        // Extrapolate the best-fit line to the edges of the graph
                        const maxGraphX = chart.options.scales.x.max;
                        chart.data.datasets[1].data = [
                            { x: 0, y: fit.intercept },
                            { x: maxGraphX, y: fit.gradient * maxGraphX + fit.intercept }
                        ];

                        // Logic for gradient triangle
                        const scaleX = chart.scales.x;
                        const xTicks = scaleX.ticks.map(t => t.value).filter(t => t >= minX && t <= maxX);
                        
                        let p1 = { x: minX, y: fit.gradient * minX + fit.intercept };
                        let p2 = { x: maxX, y: fit.gradient * maxX + fit.intercept };
                        let maxDist = 0;

                        if (xTicks.length >= 2) {
                             for (let i = 0; i < xTicks.length; i++) {
                                 for (let j = i + 1; j < xTicks.length; j++) {
                                     const x1 = xTicks[i];
                                     const x2 = xTicks[j];
                                     const y1 = fit.gradient * x1 + fit.intercept;
                                     const y2 = fit.gradient * x2 + fit.intercept;
                                     
                                     const dist = Math.hypot(x2 - x1, y2 - y1);
                                     if (dist > maxDist) {
                                         maxDist = dist;
                                         p1 = { x: x1, y: y1 };
                                         p2 = { x: x2, y: y2 };
                                     }
                                 }
                             }
                        }

                        chart.gradientPoints = { p1, p2 };
                        
                        chart.data.datasets[2].data = [
                            { x: p1.x, y: p1.y },
                            { x: p2.x, y: p1.y },
                            { x: p2.x, y: p2.y }
                        ];
                    }
                } else {
                     chart.data.datasets[1].data = [];
                     chart.data.datasets[2].data = [];
                     chart.gradientPoints = null;
                }
                
                chart.update();
            }

            function initChart() {
                chart = new Chart(graphCtx, {
                    data: {
                        datasets: [
                            { type: 'scatter', label: 'Data Points', data: [], backgroundColor: 'rgba(176, 58, 46, 0.8)', borderColor: 'rgba(128, 0, 0, 1)' },
                            { type: 'line', label: 'Best-Fit Line', data: [], borderColor: 'rgba(0, 0, 0, 0.7)', borderWidth: 2, fill: false, pointRadius: 0 },
                            {
                                type: 'line',
                                label: 'Gradient Calculation',
                                data: [],
                                borderColor: 'rgba(0, 128, 0, 0.7)',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                fill: false,
                                pointRadius: 5,
                                pointBackgroundColor: 'rgba(0, 128, 0, 0.7)',
                                showInLegend: false
                            }
                        ]
                    },
                    options: {
                        maintainAspectRatio: false,
                        scales: {
                            x: { type: 'linear', position: 'bottom', title: { display: true, text: 'Current (A)' }, min: 0, max: 5.5, ticks: { stepSize: 0.5 }, grid: { color: '#aaaaaa' }, border: { color: 'black', width: 2 } },
                            y: { title: { display: true, text: 'Terminal PD (V)' }, min: 0, max: 1.6, ticks: { stepSize: 0.2, autoSkip: false }, grid: { color: '#aaaaaa' }, border: { color: 'black', width: 2 } }
                        },
                        plugins: { 
                            tooltip: { callbacks: { label: function(context) { let label = context.dataset.label || ''; if (label) { label += ': '; } if (context.parsed.y !== null) { label += `(I: ${context.parsed.x.toFixed(2)} A, V: ${context.parsed.y.toFixed(2)} V)`; } return label; } } },
                            legend: {
                                filter: function(legendItem, chartData) {
                                    // Only show the legend item if its corresponding dataset has data.
                                    return chartData.datasets[legendItem.datasetIndex].data.length > 0;
                                }
                            }
                        }
                    }
                });
            }

            function resetData() {
                randomizeInternalResistance();
                dataPoints = [];
                updateTable();
                updateGraph();
                updateResults();
                drawScene(parseFloat(slider.value)); // Redraw meters
            }

            // --- EVENT LISTENERS ---
            slider.addEventListener('input', () => {
                const resistance = parseFloat(slider.value);
                resistanceValueSpan.textContent = resistance.toFixed(1);
                drawScene(resistance);
                updateSliderFill();
            });

            resetButton.addEventListener('click', resetData);
            uncertaintyToggle.addEventListener('change', resetData);

            physicsDetails.addEventListener('toggle', () => {
                physicsDetails.parentElement.classList.toggle('is-open', physicsDetails.open);
                 if (physicsDetails.open) {
                    // KaTeX may need a moment to reflow, re-render after transition
                    setTimeout(() => {
                        if (window.renderMathInElement) {
                            renderMathInElement(physicsDetails, katexOptions);
                        }
                    }, 400); // Should be same as transition time
                }
            });

            measureButton.addEventListener('click', () => {
                if (lastCalculatedCurrent === null || lastCalculatedTerminalPD === null) return;
                
                const current = lastCalculatedCurrent;
                const terminalPD = lastCalculatedTerminalPD;
                const R = parseFloat(slider.value);

                // Find if a point with a similar *current* already exists.
                let existingPoint = dataPoints.find(p => p.current.toFixed(2) === current.toFixed(2));

                if (existingPoint) {
                    // This is a repeat reading for an existing current value
                    if (existingPoint.pds.length < 3) {
                        existingPoint.pds.push(terminalPD);
                    } else {
                        console.log("Maximum readings for this current value reached.");
                        return; 
                    }
                } else {
                    // This is a new data point for a new current value
                    existingPoint = {
                        resistance: R, // It's still good to know what resistance caused this current
                        current: current, // The nominal current is the identifier for this data series
                        pds: [terminalPD], // Start the list of measured PDs with the current one
                        meanPD: null,
                        uncertainty: null
                    };
                    dataPoints.push(existingPoint);
                }

                const sum = existingPoint.pds.reduce((a, b) => a + b, 0);
                existingPoint.meanPD = sum / existingPoint.pds.length;
                
                if (existingPoint.pds.length > 1) {
                    const max = Math.max(...existingPoint.pds);
                    const min = Math.min(...existingPoint.pds);
                    existingPoint.uncertainty = (max - min) / existingPoint.pds.length;
                } else {
                    existingPoint.uncertainty = null;
                }
                
                dataPoints.sort((a, b) => a.current - b.current); // Sort by current ascending

                updateTable();
                updateGraph();
                updateResults();
            });

            // --- INITIALIZATION CALL ---
            randomizeInternalResistance();
            drawScene(parseFloat(slider.value));
            initChart();
            updateTable(); 
            updateSliderFill();
        });
    </script>
</body>
</html>


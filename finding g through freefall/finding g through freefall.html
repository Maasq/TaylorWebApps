<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Steph Taylor">
    <meta name="version" content="2.03.04">

    <title>The Measurement of g Through Freefall</title>

    <!-- KaTeX for LaTeX rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" xintegrity="sha384-sCutvgpopvms1PSRPY+ax+sUpl1jsmm4w6+ERsYSJOiS2BZAoAx1+t1JdGjV3b85" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" xintegrity="sha384-hIoBPJpTadox55GCNM+PBOZpTmxH+SSt+HkexsB4rUIeGajGAXXfEaY9sm2RXP5L" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" xintegrity="sha384-43gviWU0YVjaDtb/Gf1I3Oths0VyDsAlpOvx8v2iIAMoZgKcrypMe7Au17VebouV" crossorigin="anonymous"></script>

    <!-- Chart.js for graphing -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        :root {
            --claret: #800000;
            --light-claret: #B03A2E;
            --darker-claret: #8a2e24;
            --amber: #FFBF00;
            --blush-pink: #F1D4D4;
            --pale-violet: #E6E6FA;
            --white: #FFFFFF;
            --black: #000000;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: var(--pale-violet);
            margin: 0;
            padding: 20px;
        }

        /* Header Styling */
        .header-container {
            background-color: var(--claret);
            border-radius: 10px;
            border: 2px solid var(--black);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            text-align: center;
            padding: 20px;
            margin-bottom: 20px;
            color: var(--white);
        }

        .header-title {
            color: var(--amber);
            font-weight: bold;
            font-size: 2em;
            margin: 0;
            font-family: Arial, sans-serif; /* Matched from Refractive Index Sim */
        }

        .header-subtitle {
            color: var(--blush-pink);
            font-size: 1.5em;
            margin: 0; /* Adjusted margin */
            font-family: Arial, sans-serif; /* Matched from Refractive Index Sim */
            font-weight: normal; /* Matched from Refractive Index Sim */
        }

        /* Layout Styling */
        .main-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            align-items: start;
        }

        @media (max-width: 1000px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Card Styling */
        .card {
            background-color: var(--white);
            border-radius: 10px;
            border: 2px solid var(--black);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            padding: 20px;
        }

        .card h3 {
            margin-top: 0;
            border-bottom: 2px solid var(--pale-violet);
            padding-bottom: 10px;
        }
        
        /* New Wrapper to keep slider and canvas together */
        .canvas-wrapper {
            position: relative;
            width: 600px; /* Same as canvas width */
            margin: 0 auto; /* Center the whole block */
        }

        #experimentCanvas {
            display: block;
            /* margin: 0 auto; Removed margin auto from here */
            background-color: var(--white);
            border-radius: 5px;
        }

        /* Controls Styling */
        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
        }

        /* Container for VERTICAL slider */
        .slider-container {
            position: absolute;
            left: 10px; /* Adjusted relative to the wrapper edge */
            top: 42px;  /* Adjusted relative to the wrapper top */
            width: 55px; 
            height: 364px; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            z-index: 10; /* Ensure it's above canvas if overlapping */
        }
        
        .slider-container label {
             font-size: 0.9em;
             text-align: center;
             line-height: 1.2;
             order: 2; /* Label at bottom */
             margin-top: 10px;
        }

        /* Styling for VERTICAL slider via Transform */
        .slider-container input[type="range"] {
            order: 1; /* Slider at top */
            
            /* Make it vertical with 0 at bottom */
            -webkit-appearance: slider-vertical;
            writing-mode: bt-lr; 
            
            width: 8px;  
            height: 340px; 
            margin: 0;
            padding: 0;
            
            background: #ddd; 
        }

        /* Style the slider to match the button color */
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            background: #ddd;
            border-radius: 5px;
            outline: none;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--claret);
            cursor: pointer;
            border-radius: 50%;
        }

        input[type=range]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--claret);
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
        
        .button-container {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            flex-wrap: wrap; /* Allow buttons to wrap on small screens */
            justify-content: center;
        }

        .measure-button {
            background-color: var(--light-claret);
            color: var(--white);
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .measure-button:hover {
            background-color: var(--darker-claret);
        }

        .reset-button {
            position: absolute;
            top: 29px;
            right: 20px;
            transform: translateY(-50%);
            background-color: var(--amber);
            color: var(--claret);
            font-weight: bold;
            border: 1px solid var(--claret);
            padding: 8px 16px;
            border-radius: 5px;
            font-size: 1.0em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .reset-button:hover {
            background-color: #e6ac00; /* Darker amber */
        }
        
        /* New Physics Card Styling */
        .physics-card {
            grid-column: 1 / -1;
            background-color: #FFFFE0; /* Light Yellow */
            padding: 5px 20px 10px;
            transition: background-color 0.4s ease-in-out;
        }

        .physics-card.is-open {
            background-color: var(--white);
        }

        .physics-card summary {
            cursor: pointer;
            font-weight: bold;
            list-style: none;
        }

        .physics-card summary::-webkit-details-marker {
            display: none;
        }

        .physics-card summary > h3 {
            text-align: center;
            border-bottom: none;
            padding-bottom: 0;
            margin-bottom: 0;
        }

        .physics-card.is-open summary > h3 {
            text-align: left;
            border-bottom: 2px solid var(--pale-violet);
            padding-bottom: 10px;
        }

        .physics-content {
            padding-top: 15px;
        }

        .physics-content p {
            line-height: 1.6;
        }

        /* Advanced Options (Collapsible) Styling */
        .advanced-options-card {
            background-color: #FFFFE0; /* Light Yellow from refractive index sim */
            padding: 5px 20px 10px; /* Made less tall */
        }

        .advanced-options-card h3 {
            border-bottom: none;
            padding-bottom: 0;
            margin-bottom: 0;
        }
        
        details > summary {
            cursor: pointer;
            font-weight: bold;
            list-style: none; /* Remove default marker */
            text-align: center; /* Centered the title */
        }

        details > summary::-webkit-details-marker {
            display: none; /* Remove default marker for Chrome/Safari */
        }

        .advanced-options-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
        }

        .toggle-switch {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        /* Toggle Switch Styling from refractive index sim */
        .switch { position: relative; display: inline-block; width: 60px; height: 34px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider-toggle { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider-toggle:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider-toggle { background-color: #800000; }
        input:checked + .slider-toggle:before { transform: translateX(26px); }


        /* Table Styling */
        .data-table-container {
            max-height: 400px;
            overflow-y: auto;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            text-align: center;
        }

        th, td {
            padding: 8px;
            border: 1px solid black;
        }

        thead th {
            background-color: var(--light-claret);
            color: var(--white);
            position: sticky;
            top: 0;
            z-index: 1;
        }

        /* Ensure sub-header background is also sticky */
        thead tr:nth-child(2) th {
            top: 36px; /* Height of the first header row */
        }
        
        .uncertainty-cell {
            background-color: #FADBD8; /* Light Red from Refractive Index Sim */
        }

        #graph-card {
            min-height: 400px;
            display: flex;
            flex-direction: column;
        }

        .graph-container {
            position: relative;
            flex-grow: 1;
        }
    </style>
</head>
<body>

    <header class="header-container">
        <h1 class="header-title">Strathaven Academy Physics Department</h1>
        <h2 class="header-subtitle">The Measurement of g Through Freefall</h2>
    </header>

    <div class="main-layout">
        <!-- Background Physics Card -->
        <div class="card physics-card">
            <details id="physicsDetails">
                <summary><h3>Background Physics</h3></summary>
                <div class="physics-content">
                    <!-- NEW CONTENT FOR FREEFALL -->
                    <h4>Freefall and Acceleration due to Gravity ($g$)</h4>
                    <p>An object is in <strong>freefall</strong> when the only force acting on it is gravity. On Earth, the force of gravity causes all objects to accelerate towards the center of the planet at a constant rate, assuming air resistance is negligible.</p>
                    <p>This acceleration is known as the <strong>acceleration due to gravity</strong>, denoted by the symbol <strong>$g$</strong>. Near the Earth's surface, the accepted value for $g$ is approximately <strong>$9.81 \, \text{m/s}^2$</strong>.</p>
                    
                    <h4>Equations of Motion</h4>
                    <p>To describe the motion of an object falling from rest, we can use one of the standard equations of motion (or "SUVAT" equations):</p>
                    $$ s = ut + \frac{1}{2}at^2 $$
                    
                    <h4>Applying to this Experiment</h4>
                    <p>In this experiment, the ball is dropped from rest, so initial velocity $u = 0$. This gives:</p>
                    $$ s = \frac{1}{2}gt^2 $$

                    <h4>Systematic Error: Electromagnet Delay</h4>
                    <p>In a real experiment, the electromagnet may not release the ball instantly when the switch is pressed. This is due to:</p>
                    <ul>
                        <li><strong>Magnetic Remanence:</strong> The iron core retains some magnetism for a fraction of a second.</li>
                        <li><strong>Back EMF:</strong> The collapsing magnetic field induces a voltage that opposes the change, delaying the current drop.</li>
                    </ul>
                    <p>This causes the <strong>measured time</strong> to be slightly longer than the actual <strong>fall time</strong>.</p>
                    $$ t_{measured} = t_{fall} + t_{delay} $$
                    <p>On a graph of $s$ vs $t^2$, this systematic error will prevent the line of best fit from passing through the origin.</p>
                </div>
            </details>
        </div>

        <!-- Left Panel -->
        <div class="panel">
            <div class="card" style="position: relative;">
                <button id="resetButton" class="reset-button">Reset</button>
                <h3>Experiment Setup</h3>
                
                <!-- Wrapper for Canvas and Slider -->
                <div class="canvas-wrapper">
                    <!-- Vertical Slider -->
                    <div class="slider-container">
                        <label for="heightSlider">Drop Height, s = <span id="heightValue">0.50</span> m</label>
                        <input type="range" id="heightSlider" min="0.1" max="1.0" step="0.01" value="0.5">
                    </div>
                    
                    <canvas id="experimentCanvas" width="600" height="400"></canvas>
                </div>
                
                <div class="controls">
                    <!-- Slider has been moved out -->
                    <div class="button-container">
                        <button id="dropButton" class="measure-button">Drop Ball</button>
                    </div>
                </div>
            </div>

            <div class="card advanced-options-card">
                <details>
                    <summary><h3>Advanced Options</h3></summary>
                    <div class="advanced-options-controls">
                        <div class="toggle-switch">
                            <label for="uncertaintyToggle">Enable Random Uncertainty:</label>
                            <label class="switch">
                                <input type="checkbox" id="uncertaintyToggle">
                                <span class="slider-toggle"></span>
                            </label>
                        </div>
                        <div class="toggle-switch">
                            <label for="delayToggle">Enable Electromagnet Delay (Systematic):</label>
                            <label class="switch">
                                <input type="checkbox" id="delayToggle">
                                <span class="slider-toggle"></span>
                            </label>
                        </div>
                    </div>
                </details>
            </div>

            <div class="card">
                <h3>Results</h3>
                <div id="resultsOutput">
                    <p>Collect at least two data points to analyze the relationship.</p>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="panel">
            <div class="card">
                <h3>Results Table</h3>
                <div class="data-table-container">
                    <table>
                        <thead>
                            <tr>
                                <th rowspan="2">Displacement (m)</th>
                                <th colspan="4">Time (s)</th>
                                <th rowspan="2">½ t̄² (s²)</th>
                                <th rowspan="2">Random Uncertainty<br>in Time (s)</th>
                            </tr>
                            <tr>
                                <th>t₁</th>
                                <th>t₂</th>
                                <th>t₃</th>
                                <th>Mean, t̄</th>
                            </tr>
                        </thead>
                        <tbody id="dataTableBody">
                            <!-- Data rows will be inserted here -->
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="card" id="graph-card">
                <h3>Graph of Displacement vs. ½ t²</h3>
                <div class="graph-container">
                    <canvas id="resultsGraph"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const katexOptions = {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false},
                    {left: '\\(', right: '\\)', display: false},
                    {left: '\\[', right: '\\]', display: true}
                ],
                throwOnError : false
            };
            
             if (window.renderMathInElement) {
                 renderMathInElement(document.body, katexOptions);
             }

            // --- DOM ELEMENTS ---
            const canvas = document.getElementById('experimentCanvas');
            const ctx = canvas.getContext('2d');
            const heightSlider = document.getElementById('heightSlider');
            const heightValueSpan = document.getElementById('heightValue');
            const dropButton = document.getElementById('dropButton');
            const resetButton = document.getElementById('resetButton');
            const uncertaintyToggle = document.getElementById('uncertaintyToggle');
            const delayToggle = document.getElementById('delayToggle');
            const dataTableBody = document.getElementById('dataTableBody');
            const resultsOutput = document.getElementById('resultsOutput');
            const graphCtx = document.getElementById('resultsGraph').getContext('2d');
            const physicsDetails = document.getElementById('physicsDetails');

            // --- CONSTANTS & STATE ---
            const G_TRUE = 9.81; // m/s²
            const SYSTEMATIC_DELAY_S = 0.05; // 50ms delay if enabled
            
            let dataPoints = [];
            let chart;
            
            let isAnimating = false;
            let animationFrameId;
            let animationStartTime;
            let measuredTime;
            
            // Ball state
            let ball = {
                x: 0,
                y: 0,
                radius: 10
            };

            // Canvas positions
            const clampStandX = 200;
            const floorY = 370;
            const trapDoorY = 350;
            const trapDoorHeight = 10;
            const maxFallHeight_px = 300; // 300 pixels represents 1.0m
            const electromagnetY_min = trapDoorY - maxFallHeight_px - ball.radius; // y-pos for 1.0m
            const scale_px_per_m = maxFallHeight_px / 1.0; // 300 px/m

            // --- SLIDER FILL ---
            function updateSliderFill() {
                const percentage = ((heightSlider.value - heightSlider.min) / (heightSlider.max - heightSlider.min)) * 100;
                heightSlider.style.background = `linear-gradient(to right, var(--claret) ${percentage}%, #ddd ${percentage}%)`;
            }

            // --- CANVAS DRAWING ---
            function roundRect(ctx, x, y, width, height, radius) {
              if (width < 2 * radius) radius = width / 2;
              if (height < 2 * radius) radius = height / 2;
              ctx.beginPath();
              ctx.moveTo(x + radius, y);
              ctx.arcTo(x + width, y, x + width, y + height, radius);
              ctx.arcTo(x + width, y + height, x, y + height, radius);
              ctx.arcTo(x, y + height, x, y, radius);
              ctx.arcTo(x, y, x + width, y, radius);
              ctx.closePath();
            }
            
            function setShadow(ctx) {
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;
            }

            function drawTimer(time_s) {
                const meterX = 450;
                const meterY = 70;
                const meterWidth = 90;
                const meterHeight = 60;
                const cornerRadius = 5;

                ctx.save();
                setShadow(ctx);
                ctx.fillStyle = 'gold';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                roundRect(ctx, meterX - meterWidth / 2, meterY - meterHeight / 2, meterWidth, meterHeight, cornerRadius);
                ctx.fill();
                ctx.restore();
                ctx.stroke();
                
                // LCD Screen
                const lcdWidth = 70;
                const lcdHeight = 24;
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(meterX - lcdWidth / 2, meterY - lcdHeight / 2, lcdWidth, lcdHeight);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1;
                ctx.strokeRect(meterX - lcdWidth / 2, meterY - lcdHeight / 2, lcdWidth, lcdHeight);
                
                // Text
                ctx.fillStyle = 'black';
                ctx.lineWidth = 2;
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Timer', meterX, meterY - (meterHeight + lcdHeight) / 4);
                ctx.font = '12px "Courier New", monospace';
                ctx.fillText(time_s.toFixed(3) + ' s', meterX, meterY);
            }

            function drawScene(current_s, time_s) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // --- 1. Calculate Core Positions FIRST ---
                const electromagnetY = trapDoorY - (current_s * scale_px_per_m) - 15 - (2 * ball.radius);
                ball.x = clampStandX + 25; // Center of electromagnet
                
                // Ensure ball.y is correct for current state before drawing
                if (!isAnimating) {
                    ball.y = electromagnetY + 15 + ball.radius; // At rest/reset, held by magnet
                }
                
                // --- Draw Clamp Stand ---
                ctx.save();
                setShadow(ctx);
                ctx.fillStyle = '#696969';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1;
                ctx.fillRect(clampStandX - 5, 10, 10, 360);
                ctx.strokeRect(clampStandX - 5, 10, 10, 360);
                ctx.fillRect(clampStandX - 50, floorY, 100, 20);
                ctx.strokeRect(clampStandX - 50, floorY, 100, 20);
                ctx.restore();
                
                // --- Draw Trap Door ---
                const trapDoorWidth = 80;
                let trapDoorAngle = 0;
                let ballY_on_impact = trapDoorY - ball.radius;

                if (isAnimating && ball.y >= ballY_on_impact) {
                    trapDoorAngle = -Math.PI / 6; // Open
                }
                
                ctx.save();
                setShadow(ctx);
                ctx.translate(clampStandX + 5, trapDoorY); // Hinge point
                ctx.rotate(trapDoorAngle);
                ctx.fillStyle = '#AAAAAA';
                ctx.fillRect(0, -trapDoorHeight / 2, trapDoorWidth, trapDoorHeight);
                ctx.strokeRect(0, -trapDoorHeight / 2, trapDoorWidth, trapDoorHeight);
                ctx.restore();
                
                // Trap door contact/Clamp
                ctx.save();
                ctx.fillStyle = 'black';
                ctx.fillRect(clampStandX + 5 + trapDoorWidth, trapDoorY - trapDoorHeight, 5, 10);
                ctx.restore();
                ctx.save();
                setShadow(ctx);
                ctx.fillStyle = '#888';
                ctx.fillRect(clampStandX - 15, trapDoorY - 10, 20, 20);
                ctx.strokeRect(clampStandX - 15, trapDoorY - 10, 20, 20);
                ctx.restore();

                // --- Draw Electromagnet & LED ---
                ctx.save();
                setShadow(ctx);
                ctx.fillStyle = '#555';
                ctx.fillRect(clampStandX + 5, electromagnetY - 15, 40, 30);
                ctx.strokeRect(clampStandX + 5, electromagnetY - 15, 40, 30);
                
                // LED Logic: 
                // We consider the magnet ON if the ball is physically at the top.
                // When "dropping", ball stays at top for delay duration (so magnet still visually ON/Green),
                // then drops (LED turns red).
                const ballAtTop = Math.abs(ball.y - (electromagnetY + 15 + ball.radius)) < 2;
                // If animating, we check if we are in the "delay" phase (ball still at top)
                const magnetOn = ballAtTop && (!isAnimating || (isAnimating && time_s < (delayToggle.checked ? SYSTEMATIC_DELAY_S : 0)));
                
                ctx.fillStyle = magnetOn ? '#00FF00' : '#FF0000'; 
                ctx.shadowBlur = 10;
                ctx.shadowColor = ctx.fillStyle;
                ctx.beginPath();
                ctx.arc(clampStandX + 25, electromagnetY, 4, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.restore(); // Restore to remove LED glow

                ctx.save();
                setShadow(ctx);
                ctx.fillStyle = '#888';
                ctx.fillRect(clampStandX - 15, electromagnetY - 10, 20, 20);
                ctx.strokeRect(clampStandX - 15, electromagnetY - 10, 20, 20);
                ctx.restore();

                // --- Draw Ball ---
                ctx.save();
                setShadow(ctx);
                const ballGrad = ctx.createRadialGradient(ball.x - 3, ball.y - 3, 2, ball.x, ball.y, ball.radius);
                ballGrad.addColorStop(0, '#ff4d4d'); // Highlight
                ballGrad.addColorStop(1, '#800000'); // Shadow/Dark Red
                ctx.fillStyle = ballGrad;
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.restore();

                // --- Draw Guide Line (Red Dashed Line) ---
                if (!isAnimating) {
                    ctx.save();
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]); 
                    ctx.beginPath();
                    ctx.moveTo(110, ball.y + ball.radius); 
                    ctx.lineTo(ball.x, ball.y + ball.radius);
                    ctx.stroke();
                    ctx.restore();
                }

                // --- Draw Timer ---
                drawTimer(time_s);
                
                // --- Draw Ruler (Metre Stick) ---
                const rulerLeftX = 70;
                const rulerWidth = 40;
                const rulerRightX = rulerLeftX + rulerWidth; // 110
                const rulerTopY = 30;
                const rulerHeight = 340;

                ctx.save();
                setShadow(ctx);
                ctx.fillStyle = '#FFFFFF'; // White fill
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1;
                ctx.fillRect(rulerLeftX, rulerTopY, rulerWidth, rulerHeight);
                ctx.strokeRect(rulerLeftX, rulerTopY, rulerWidth, rulerHeight);
                ctx.restore();
                
                ctx.fillStyle = 'black';
                ctx.strokeStyle = 'black';
                ctx.textAlign = 'right';
                ctx.font = '10px Arial';
                
                for (let h_m = 0; h_m <= 1.0; h_m += 0.1) {
                    let y = trapDoorY - (h_m * scale_px_per_m);
                    ctx.beginPath();
                    ctx.moveTo(rulerRightX, y);
                    ctx.lineTo(rulerRightX - 10, y);
                    ctx.stroke();
                    ctx.fillText(h_m.toFixed(1), rulerRightX - 15, y);
                }
                ctx.fillText("m", rulerRightX - 15, rulerTopY - 10);
                ctx.textBaseline = 'alphabetic'; // Reset
            }
            
            // --- ANIMATION LOOP ---
            function runAnimation(animationStartTimestamp) {
                const elapsed_ms = performance.now() - animationStartTimestamp;
                let elapsed_s = elapsed_ms / 1000.0;
                
                const s_to_fall_m = parseFloat(heightSlider.value);
                const true_fall_time_s = Math.sqrt((2 * s_to_fall_m) / G_TRUE);
                const delay_s = delayToggle.checked ? SYSTEMATIC_DELAY_S : 0;
                
                // Determine Physics Phase
                let ball_falling = false;
                let fall_elapsed_s = 0;

                if (elapsed_s < delay_s) {
                    // Phase 1: Delay (Ball hangs)
                    ball_falling = false;
                } else {
                    // Phase 2: Falling
                    ball_falling = true;
                    fall_elapsed_s = elapsed_s - delay_s;
                }
                
                // Calculate Scale factor for timer display
                // The timer must end at exactly 'measuredTime' when the physics ends at (true_fall + delay)
                const total_physics_duration = true_fall_time_s + delay_s;
                const display_ratio = measuredTime / total_physics_duration;
                let display_time_s = elapsed_s * display_ratio;

                // Stop condition based on PHYSICS time (not measured time)
                if (fall_elapsed_s < true_fall_time_s) {
                    if (ball_falling) {
                        const s_fallen_m = 0.5 * G_TRUE * fall_elapsed_s * fall_elapsed_s;
                        const electromagnetY_start = trapDoorY - (s_to_fall_m * scale_px_per_m) - 15 - (2 * ball.radius);
                        const ball_start_y = electromagnetY_start + 15 + ball.radius;
                        ball.y = ball_start_y + (s_fallen_m * scale_px_per_m);
                    } else {
                         // Ensure ball stays at top during delay
                        const electromagnetY_start = trapDoorY - (s_to_fall_m * scale_px_per_m) - 15 - (2 * ball.radius);
                         ball.y = electromagnetY_start + 15 + ball.radius;
                    }
                    animationFrameId = requestAnimationFrame(runAnimation.bind(null, animationStartTimestamp));
                } else {
                    // Hit
                    ball.y = trapDoorY - ball.radius;
                    display_time_s = measuredTime; // Snap to final measured time
                    isAnimating = false;
                    dropButton.disabled = false;
                    recordMeasurement(s_to_fall_m, measuredTime);
                }
                
                drawScene(s_to_fall_m, display_time_s);
            }

            // --- CALCULATIONS ---
            function calculateFallTime(s_m) {
                const true_fall_time = Math.sqrt((2 * s_m) / G_TRUE);
                
                // Add systematic delay to the "true" base time
                const delay = delayToggle.checked ? SYSTEMATIC_DELAY_S : 0;
                let measured_time = true_fall_time + delay;

                // Apply random uncertainty to the TOTAL duration
                if (uncertaintyToggle.checked) {
                    const uncertaintyFactor = (Math.random() - 0.5) * 0.10; // +/- 5% random error
                    measured_time *= (1 + uncertaintyFactor);
                }

                return { measured_time };
            }
            
            function calculateBestFit() {
                const validPoints = dataPoints.filter(p => p.meanTime !== null);
                if (validPoints.length < 2) return null;

                let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
                const n = validPoints.length;

                validPoints.forEach(p => {
                    const x = p.half_t_sq; // X is ½ t̄²
                    const y = p.displacement_s; // Y is s
                    sumX += x;
                    sumY += y;
                    sumXY += x * y;
                    sumX2 += x * x;
                });

                const gradient = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                const intercept = (sumY - gradient * sumX) / n;
                
                return { gradient, intercept }; // Gradient = g
            }

            // --- UPDATERS ---
            function recordMeasurement(s_m, t_s) {
                let existingPoint = dataPoints.find(p => p.displacement_s.toFixed(2) === s_m.toFixed(2));

                if (existingPoint) {
                    if (existingPoint.times.length < 3) {
                        existingPoint.times.push(t_s);
                    } else {
                        return;
                    }
                } else {
                    existingPoint = {
                        displacement_s: s_m,
                        times: [t_s],
                        meanTime: null,
                        half_t_sq: null,
                        uncertainty: null
                    };
                    dataPoints.push(existingPoint);
                }

                const sum = existingPoint.times.reduce((a, b) => a + b, 0);
                existingPoint.meanTime = sum / existingPoint.times.length;
                existingPoint.half_t_sq = 0.5 * Math.pow(existingPoint.meanTime, 2);
                
                if (existingPoint.times.length > 1) {
                    const max = Math.max(...existingPoint.times);
                    const min = Math.min(...existingPoint.times);
                    existingPoint.uncertainty = (max - min) / existingPoint.times.length;
                } else {
                    existingPoint.uncertainty = null;
                }
                
                dataPoints.sort((a, b) => a.displacement_s - b.displacement_s);

                updateTable();
                updateGraph();
                updateResults();
            }
            
            function updateTable() {
                dataTableBody.innerHTML = '';
                
                dataPoints.forEach(p => {
                    const t1 = p.times[0] !== undefined ? p.times[0].toFixed(3) : '-';
                    const t2 = p.times[1] !== undefined ? p.times[1].toFixed(3) : '-';
                    const t3 = p.times[2] !== undefined ? p.times[2].toFixed(3) : '-';
                    const mean = p.meanTime !== null ? p.meanTime.toFixed(3) : '-';
                    const half_t_sq = p.half_t_sq !== null ? p.half_t_sq.toFixed(3) : '-';
                    const uncertainty = p.uncertainty !== null ? p.uncertainty.toFixed(3) : '-';

                    const row = `
                        <tr>
                            <td>${p.displacement_s.toFixed(2)}</td>
                            <td>${t1}</td>
                            <td>${t2}</td>
                            <td>${t3}</td>
                            <td><b>${mean}</b></td>
                            <td>${half_t_sq}</td>
                            <td class="uncertainty-cell">${uncertainty}</td>
                        </tr>
                    `;
                    dataTableBody.innerHTML += row;
                });

                const emptyRowsNeeded = Math.max(0, 5 - dataPoints.length);
                for (let i = 0; i < emptyRowsNeeded; i++) {
                    const emptyRow = `<tr><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td class="uncertainty-cell">-</td></tr>`;
                    dataTableBody.innerHTML += emptyRow;
                }
            }
            
            function updateResults() {
                const fit = calculateBestFit();
                if (!fit) {
                    resultsOutput.innerHTML = '<p>Collect at least two data points to analyze the relationship.</p>';
                    return;
                }

                const gradient_g = fit.gradient;
                const intercept = fit.intercept;
                
                let katexString = `
                    <p>The relationship for an object in freefall is $s = \\frac{1}{2}gt^2$.</p>
                    <p>This is in the form of a straight line, $y = mx + c$.</p>
                    <p><b>Gradient (m) = ${gradient_g.toFixed(2)} m/s²</b></p>
                    <p>The <b>Acceleration due to Gravity (g) = ${gradient_g.toFixed(2)} m/s²</b></p>
                    <p><b>Y-Intercept (c) = ${intercept.toFixed(2)} m</b></p>
                `;
                
                // Add commentary on the intercept if Delay is active
                if (delayToggle.checked) {
                    katexString += `<p style="color: var(--claret);"><b>Note:</b> The non-zero Y-intercept is likely caused by the systematic error from the electromagnet delay.</p>`;
                }

                resultsOutput.innerHTML = katexString;
                
                 if (window.renderMathInElement) {
                     renderMathInElement(resultsOutput, katexOptions);
                 }
            }

            function updateGraph() {
                const scatterData = dataPoints
                    .filter(p => p.meanTime !== null)
                    .map(p => ({ x: p.half_t_sq, y: p.displacement_s }));
                
                chart.data.datasets[0].data = scatterData;

                const fit = calculateBestFit();

                if (fit) {
                    const xValues = scatterData.map(p => p.x).sort((a,b) => a - b);
                    if (xValues.length > 0) {
                        const minX = 0; // Start from origin
                        const maxX = chart.options.scales.x.max;
                        
                        chart.data.datasets[1].data = [
                            { x: 0, y: fit.intercept },
                            { x: maxX, y: fit.gradient * maxX + fit.intercept }
                        ];

                        // Logic for gradient triangle
                        const dataMinX = xValues[0];
                        const dataMaxX = xValues[xValues.length - 1];
                        const scaleX = chart.scales.x;
                        const xTicks = scaleX.ticks.map(t => t.value).filter(t => t >= dataMinX && t <= dataMaxX);
                        
                        let p1 = { x: dataMinX, y: fit.gradient * dataMinX + fit.intercept };
                        let p2 = { x: dataMaxX, y: fit.gradient * dataMaxX + fit.intercept };
                        let maxDist = 0;

                        if (xTicks.length >= 2) {
                             for (let i = 0; i < xTicks.length; i++) {
                                 for (let j = i + 1; j < xTicks.length; j++) {
                                     const x1 = xTicks[i];
                                     const x2 = xTicks[j];
                                     const y1 = fit.gradient * x1 + fit.intercept;
                                     const y2 = fit.gradient * x2 + fit.intercept;
                                     
                                     const dist = Math.hypot(x2 - x1, y2 - y1);
                                     if (dist > maxDist) {
                                         maxDist = dist;
                                         p1 = { x: x1, y: y1 };
                                         p2 = { x: x2, y: y2 };
                                     }
                                 }
                             }
                        }

                        chart.gradientPoints = { p1, p2 };
                        
                        chart.data.datasets[2].data = [
                            { x: p1.x, y: p1.y },
                            { x: p2.x, y: p1.y },
                            { x: p2.x, y: p2.y }
                        ];
                    }
                } else {
                     chart.data.datasets[1].data = [];
                     chart.data.datasets[2].data = [];
                     chart.gradientPoints = null;
                }
                
                chart.update();
            }

            function initChart() {
                // Max x = 0.5 * t^2 = 0.5 * (2*s/g) = s/g = 1.0 / 9.81 = ~0.102
                const xAxisMax = 0.11;
                
                chart = new Chart(graphCtx, {
                    data: {
                        datasets: [
                            { type: 'scatter', label: 'Data Points', data: [], backgroundColor: 'rgba(176, 58, 46, 0.8)', borderColor: 'rgba(128, 0, 0, 1)', },
                            { type: 'line', label: 'Best-Fit Line', data: [], borderColor: 'rgba(0, 0, 0, 0.7)', borderWidth: 2, fill: false, pointRadius: 0 },
                            {
                                type: 'line',
                                label: 'Gradient Calculation',
                                data: [],
                                borderColor: 'rgba(0, 128, 0, 0.7)',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                fill: false,
                                pointRadius: 0,
                                showInLegend: false
                            }
                        ]
                    },
                    options: {
                        maintainAspectRatio: false,
                        scales: {
                            x: { type: 'linear', position: 'bottom', title: { display: true, text: '½ t̄² (s²)' }, min: 0, max: xAxisMax, ticks: { stepSize: 0.01 }, grid: { color: '#aaaaaa' }, border: { color: 'black', width: 2 } },
                            y: { title: { display: true, text: 'Displacement, s (m)' }, min: 0, max: 1.1, ticks: { stepSize: 0.1 }, grid: { color: '#aaaaaa' }, border: { color: 'black', width: 2 } }
                        },
                        plugins: { 
                            tooltip: { callbacks: { label: function(context) { let label = context.dataset.label || ''; if (label) { label += ': '; } if (context.parsed.y !== null) { label += `(s: ${context.parsed.y.toFixed(2)} m, ½t²: ${context.parsed.x.toFixed(3)} s²)`; } return label; } } },
                            legend: {
                                filter: function(legendItem, chartData) {
                                    return chartData.datasets[legendItem.datasetIndex].data.length > 0;
                                }
                            }
                        }
                    }
                });
            }

            function resetData() {
                dataPoints = [];
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                isAnimating = false;
                dropButton.disabled = false;
                
                updateTable();
                updateGraph();
                updateResults();
                
                const s_m = parseFloat(heightSlider.value);
                drawScene(s_m, 0.0); // Redraw initial scene
            }

            function initializeExperiment() {
                initChart();
                heightSlider.value = 0.5; // Set slider to default
                resetData();
                heightValueSpan.textContent = parseFloat(heightSlider.value).toFixed(2);
                updateSliderFill();
            }

            // --- EVENT LISTENERS ---
            heightSlider.addEventListener('input', () => {
                if (isAnimating) return;
                const s_m = parseFloat(heightSlider.value);
                heightValueSpan.textContent = s_m.toFixed(2);
                drawScene(s_m, 0.0);
                updateSliderFill();
            });

            resetButton.addEventListener('click', resetData);
            uncertaintyToggle.addEventListener('change', resetData);
            delayToggle.addEventListener('change', resetData);

            dropButton.addEventListener('click', () => {
                if (isAnimating) return;
                
                const s_m = parseFloat(heightSlider.value);
                
                // Check if we can add another reading for this height
                let existingPoint = dataPoints.find(p => p.displacement_s.toFixed(2) === s_m.toFixed(2));
                if (existingPoint && existingPoint.times.length >= 3) {
                    console.log("Maximum readings for this height.");
                    return;
                }

                isAnimating = true;
                dropButton.disabled = true;
                
                const { measured_time } = calculateFallTime(s_m);
                measuredTime = measured_time; // Store for the animation to use
                
                animationStartTime = performance.now();
                // Ensure we pass the correct variable 'animationStartTime' here
                animationFrameId = requestAnimationFrame(runAnimation.bind(null, animationStartTime));
            });
            
            physicsDetails.addEventListener('toggle', () => {
                physicsDetails.parentElement.classList.toggle('is-open', physicsDetails.open);
                 if (physicsDetails.open) {
                    setTimeout(() => {
                        if (window.renderMathInElement) {
                            renderMathInElement(physicsDetails, katexOptions);
                        }
                    }, 400); 
                }
            });

            // --- INITIALIZATION CALL ---
            initializeExperiment();
        });
    </script>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">

    <meta name="author" content="Steph Taylor">
    <meta name="version" content="1.0.0">

<title>Refractive Index Simulation</title>
<style>
    :root {
        --claret: #800000;
        --amber: #FFBF00;
    }
    body {
        font-family: Arial, sans-serif;
        background-color: #E6E6FA; /* Pale Violet */
        margin: 0;
        padding: 20px;
    }
    .header-container {
        background-color: #800000; /* Claret */
        color: #FFBF00; /* Amber */
        padding: 20px;
        text-align: center;
        border-radius: 15px;
        border: 2px solid black;
        box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
        margin-bottom: 20px;
    }
    .main-title {
        font-size: 2em;
        font-weight: bold;
    }
    .sub-title {
        font-size: 1.5em;
        color: #F1D4D4; /* Blush Pink */
    }
    .medium-selector, .advanced-options-content {
        display: flex;
        justify-content: space-around;
        padding: 10px 0;
        align-items: center;
    }
    .medium-selector {
        margin-bottom: 15px;
    }
    .medium-selector label {
        cursor: pointer;
        font-size: 1.1em;
    }
    .main-content {
        display: flex;
        flex-direction: row;
        gap: 20px;
    }
    .left-panel, .right-panel {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 20px;
    }
    .app-box {
        position: relative; /* Needed for positioning the reset button */
        background-color: white;
        padding: 20px;
        border-radius: 15px;
        border: 2px solid black;
        box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
    }
    /* --- MODIFIED: Header styling updated --- */
    .app-box h3, .app-box summary {
        margin-top: 0;
        text-align: left;
        font-size: 1.2em;
        font-weight: bold;
        border-bottom: 2px solid #eee;
        padding-bottom: 10px;
        margin-bottom: 10px;
    }
    /* --- NEW: Specific style for Advanced Options header --- */
    .advanced-options-card summary {
        text-align: center;
        border-bottom: none;
        padding-bottom: 0;
        margin-bottom: 0px;
    }
    .advanced-options-card {
        background-color: #FFFFE0; /* Light Yellow */
        padding: 10px 20px;
    }
    .advanced-options-content {
        padding: 5px 0;
    }
    details > summary {
        cursor: pointer;
        list-style: none;
        color: #333;
    }
    details > summary::-webkit-details-marker {
        display: none;
    }
    #simulationCanvas {
        display: block;
        margin: 0 auto;
    }
    .simulation-controls {
        text-align: center;
    }
    input[type="range"].slider {
        -webkit-appearance: none;
        appearance: none;
        width: 80%;
        height: 8px;
        margin: 10px 0;
        background: #ddd; /* Initial track color */
        border-radius: 5px;
        outline: none;
        cursor: pointer;
    }

    input[type="range"].slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        background: #B03A2E; /* Same color as button */
        border-radius: 50%;
        border: none;
        box-shadow: 0 0 3px rgba(0,0,0,0.4);
        cursor: pointer;
        margin-top: -6px; /* Vertically center thumb */
    }

    input[type="range"].slider::-moz-range-thumb {
        width: 20px;
        height: 20px;
        background: #B03A2E; /* Same color as button */
        border-radius: 50%;
        border: none;
        box-shadow: 0 0 3px rgba(0,0,0,0.4);
        cursor: pointer;
    }
    button {
        padding: 10px 20px;
        font-size: 1em;
        cursor: pointer;
        border-radius: 8px;
        border: 1px solid #800000;
        background-color: #B03A2E; /* Light Claret */
        color: white;
        font-weight: bold;
    }
    button:hover {
        background-color: #800000;
    }
    table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 10px;
    }
    th, td {
        border: 1px solid black;
        padding: 8px;
        text-align: center;
        height: 22px;
    }
    th {
        background-color: #B03A2E; /* Light Claret */
        color: white;
    }
    #gradient-calculation, #final-statement {
        font-size: 1.1em;
        margin-top: 10px;
    }
    .switch { position: relative; display: inline-block; width: 60px; height: 34px; }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider-toggle { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
    .slider-toggle:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
    input:checked + .slider-toggle { background-color: #800000; }
    input:checked + .slider-toggle:before { transform: translateX(26px); }

    .medium-button {
        padding: 8px 16px;
        border: 1px solid transparent;
        border-radius: 8px;
        cursor: pointer;
        color: #333;
        font-weight: bold;
        transition: background-color 0.3s, color 0.3s;
    }

    .medium-button.active {
        background-color: #B03A2E;
        color: white;
        border-color: #800000;
    }

    .uncertainty-cell {
        background-color: #FADBD8; /* Light Red */
    }

    .reset-button {
        position: absolute;
        top: 29px;
        right: 20px;
        transform: translateY(-50%);
        background-color: var(--amber);
        color: var(--claret);
        font-weight: bold;
        border: 1px solid var(--claret);
        padding: 8px 16px;
        border-radius: 5px;
        font-size: 1.0em;
        cursor: pointer;
        transition: all 0.3s ease;
    }

    .reset-button:hover {
        background-color: #e6ac00; /* Darker amber */
    }

    /* --- NEW INSTRUCTIONS CARD --- */
    .instructions-card {
        background-color: #FFFFE0; /* Light Yellow */
        transition: background-color 0.5s ease;
        padding: 10px 20px;
        margin-bottom: 20px;
    }
    .instructions-card.is-open {
        background-color: white;
    }
    .instructions-card > details > summary {
        text-align: center;
        border-bottom: none;
        padding-bottom: 0;
        margin-bottom: 0;
    }
    .instructions-card.is-open > details > summary {
        text-align: left;
        border-bottom: 2px solid #eee;
        padding-bottom: 10px;
        margin-bottom: 10px;
    }

    .physics-diagram {
        display: block;
        float: left;
		margin-right: 15px; /* Adds space between the image and the text */
		margin-bottom: 10px; /* Adds space below the image */
		max-width: 80%;
        border-radius: 10px;
        border: 1px solid #ccc;
    }
	
	.force-below {
		clear: both; /* This is the key property! */
	}

</style>
<script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.4/dist/Chart.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/regression/dist/regression.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" xintegrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI76/yTUeZkRb5joUkyk8BCjA5" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" xintegrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4oaaGpoIsJVKImADGzcG" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" xintegrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"></script>
</head>
<body>

<div class="header-container">
    <div class="main-title">Strathaven Academy Physics Department</div>
    <div class="sub-title">Refractive Index Simulation</div>
</div>

<div class="app-box instructions-card" id="instructionsCard">
    <details id="instructionsDetails">
        <summary>Background Physics</summary>
        <div class="instructions-content">
            <h4>Definition of Refraction</h4>
            <p>
                Refraction is the change in direction of a wave when it passes from one medium to another. This change in direction is caused by a change in the wave's speed. For light, a medium's optical density determines the speed of light within it. The measure of this optical density is called the refractive index (\(n\)).
            </p>
            <h4>Snell's Law</h4>
            <img src="refraction.webp" alt="Diagram showing refraction of light" class="physics-diagram">
            <p>
                The relationship between the angles of incidence and refraction and the refractive indices of the two media is described by Snell's Law:
                $$ n_1 \sin(\theta_1) = n_2 \sin(\theta_2) $$
                Where \(n_1\) and \(\theta_1\) are the refractive index and angle in the first medium, and \(n_2\) and \(\theta_2\) are for the second medium. The angles are always measured from the 'normal' - a line perpendicular to the surface.
            </p>
            <p>
                In this simulation, light travels from air into another medium. The refractive index of air (\(n_1\)) is approximately 1.00. Let \(n_2 = n\). Substituting this into Snell's law gives:
                $$ 1 \cdot \sin(\theta_1) = n \sin(\theta_2) $$
                $$ n = \frac{\sin(\theta_1)}{\sin(\theta_2)} $$
                This shows that a graph of \(\sin(\theta_1)\) vs \(\sin(\theta_2)\) will be a straight line with a gradient equal to the refractive index, \(n\).
            </p>
			<p class="force-below">
			</p>
            <h4 class="physics-subheader">Derivation of Snell's Law</h4>
             <img src="snells.webp" alt="Diagram showing wavefronts for Snell's Law derivation" class="physics-diagram">
           <p>
                Because the frequency of a wave (\(f\)) is constant, but the
                speed of light (\(v_1\) and \(v_2\)) is
                different in the two media, the wavelength must change. This follows
                from the fundamental wave relationship: \(v=f\lambda\), which means \(\lambda=v/f\).
            </p>
                <p><b>In medium 1</b>: \(\lambda_1=v_1/f\)<br>
                <b>In medium 2</b>: \(\lambda_2=v_2/f\)</p>
            <p>
                The diagram shows two wavefronts (the green lines)
                approaching the boundary between two media. They are obviously separated by one
                wavelength. The first wave has fully entered medium 2 and the second wave is on
                the point of entering it.
            </p>
            <p>
                Consider the two right-angled triangles formed by the
                wavefronts and the boundary line.
            </p>
				<p> <b>The top triangle</b> (in medium 1) has a hypotenuse of length <b><i>L</i></b>. The side opposite the angle of incidence (\(\theta_1\)) is the distance between two wave crests, which is the wavelength in that medium, \(\lambda_1\). From basic trigonometry,
                     we can write: 
                    $$ \sin(\theta_1) = \frac{\lambda_1}{L} $$
                </p>
                <p> <b>The bottom triangle</b> (in medium 2) shares the same hypotenuse <b><i>L</i></b>. The side opposite the angle of refraction (\(\theta_2\)) is the wavelength in the second medium, \(\lambda_2\). Similarly, for this triangle: 
                    $$ \sin(\theta_2) = \frac{\lambda_2}{L} $$
                </p>
            <p>
                Now, we can rearrange to find the common side L in
                both equations: 
                $$ L = \frac{\lambda_1}{\sin(\theta_1)} \quad \text{and} \quad L = \frac{\lambda_2}{\sin(\theta_2)} $$
            </p>
            <p>
                Since L is the same for both, we can set the two
                expressions equal to each other: 
                $$ \frac{\lambda_1}{\sin(\theta_1)} = \frac{\lambda_2}{\sin(\theta_2)} $$
            </p>
            <p>
                Now, substitute the expressions for wavelength (\(\lambda_1=v_1/f\) and \(\lambda_2=v_2/f\)): 
                $$ \frac{v_1/f}{\sin(\theta_1)} = \frac{v_2/f}{\sin(\theta_2)} $$
            </p>
            <p>
                The frequency (\(f\)) is on both sides, so it cancels out,
                leaving us with: 
                $$ \frac{v_1}{\sin(\theta_1)} = \frac{v_2}{\sin(\theta_2)} $$
            </p>
            <p>
                Rearranging this gives Snell's Law, expressed in terms of
                velocities: 
                $$ \frac{\sin(\theta_1)}{\sin(\theta_2)} = \frac{v_1}{v_2} $$
            </p>
            <h4>Refractive Index and Wavelength</h4>
            <p>
                When light enters a new medium, its frequency remains constant, but its speed and wavelength change. The relationship is given by:
                $$ \frac{n_2}{n_1} = \frac{v_1}{v_2} = \frac{\lambda_1}{\lambda_2} $$
                This means that in a more optically dense medium (higher \(n\)), the speed and wavelength of light both decrease.
            </p>
        </div>
    </details>
</div>

<div class="main-content">
    <div class="left-panel">
        <div class="app-box">
            <button class="reset-button" id="resetButton">Reset</button>
            <h3>Experiment Setup</h3>
            <div class="medium-selector">
                <div class="medium-button active" data-value="perspex">Perspex</div>
                <div class="medium-button" data-value="water">Water</div>
                <div class="medium-button" data-value="glycerol">Glycerol</div>
                <div class="medium-button" data-value="zircon">Zircon</div>
                <div class="medium-button" data-value="diamond">Diamond</div>
            </div>
            <canvas id="simulationCanvas" width="500" height="350"></canvas>
            <div class="simulation-controls">
                <label for="angleSlider">Angle of Incidence: <span id="angleValue">45</span>°</label>
                <br>
                <input type="range" min="0" max="89" value="45" class="slider" id="angleSlider">
                <br>
                <button id="measureButton">Measure Angles</button>
            </div>
        </div>
         <div class="app-box advanced-options-card">
             <details>
                <summary>Advanced Options</summary>
                <div class="advanced-options-content">
                    <label for="uncertaintyToggle">Enable Random Uncertainty:</label>
                    <label class="switch">
                        <input type="checkbox" id="uncertaintyToggle">
                        <span class="slider-toggle"></span>
                    </label>
                </div>
            </details>
        </div>
        <div class="app-box" id="results-section">
            <h3>Results</h3>
            <div id="gradient-calculation">Gradient (\(m\)): Not yet calculated.</div>
            <div id="final-statement">The measured refractive index is: N/A</div>
        </div>
    </div>
    <div class="right-panel">
        <div class="app-box">
            <h3 id="tableMediumLabel"></h3>
            <table id="dataTable">
                <thead>
                    <tr>
                        <th rowspan="2">Angle of Incidence (°)</th>
                        <th colspan="4">Angle of Refraction (°)</th>
                        <th rowspan="2">\(\sin(i)\)</th>
                        <th rowspan="2">\(\sin(\bar{r})\)</th>
                        <th rowspan="2">random uncertainty in Angle of Refraction (°)</th>
                    </tr>
                    <tr>
                        <th>r₁</th>
                        <th>r₂</th>
                        <th>r₃</th>
                        <th>Mean</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
        <div class="app-box">
            <h3 id="graphMediumLabel"></h3>
            <canvas id="resultsGraph"></canvas>
        </div>
    </div>
</div>

<script defer>
    // --- Global Variables & Constants ---
    const n1 = 1.0;
    const refractiveIndices = { perspex: 1.5, water: 1.33, glycerol: 1.47, zircon: 1.92, diamond: 2.42 };
    const mediumColors = { perspex: '#E5E4E8', water: '#B0E0E6', glycerol: '#FAFAD2', zircon: '#E0F2E9', diamond: '#F0FFFF' };
    let n2 = refractiveIndices.perspex;
    const UNCERTAINTY_PERCENTAGE = 0.05;

    const canvas = document.getElementById('simulationCanvas');
    const ctx = canvas.getContext('2d');
    const slider = document.getElementById('angleSlider');
    const angleValueSpan = document.getElementById('angleValue');
    const measureButton = document.getElementById('measureButton');
    const dataTableBody = document.querySelector('#dataTable tbody');
    const gradientDisplay = document.getElementById('gradient-calculation');
    const refractiveIndexDisplay = document.getElementById('final-statement');
    const tableMediumLabel = document.getElementById('tableMediumLabel');
    const graphMediumLabel = document.getElementById('graphMediumLabel');
    const uncertaintyToggle = document.getElementById('uncertaintyToggle');
    const instructionsDetails = document.getElementById('instructionsDetails');
    const instructionsCard = document.getElementById('instructionsCard');

    let angleIncidence = parseFloat(slider.value);
    let dataPoints = [];
    let chart;

    // --- Helper & Drawing Functions ---
    function capitalize(str) { return str.charAt(0).toUpperCase() + str.slice(1); }
    
    function updateSliderBackground(slider) {
        const min = slider.min || 0;
        const max = slider.max || 100;
        const value = slider.value;
        const percentage = ((value - min) / (max - min)) * 100;
        const color = '#B03A2E'; // Same as the button
        const trackColor = '#dddddd'; 
        slider.style.background = `linear-gradient(to right, ${color} ${percentage}%, ${trackColor} ${percentage}%)`;
    }

    function drawArrowhead(ctx, fromX, fromY, toX, toY, size) {
        const angle = Math.atan2(toY - fromY, toX - fromX);
        ctx.save(); ctx.translate(toX, toY); ctx.rotate(angle);
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-size, size / 2); ctx.lineTo(-size, -size / 2); ctx.closePath(); ctx.fill();
        ctx.restore();
    }
    function drawSimulation() {
        const width = canvas.width, height = canvas.height, boundaryY = height / 2, entryPointX = width / 2, blockRadius = 150;
        const currentMediumName = Object.keys(refractiveIndices).find(key => refractiveIndices[key] === n2);

        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = 'white'; ctx.fillRect(0, 0, width, height);
        ctx.beginPath(); ctx.arc(entryPointX, boundaryY, blockRadius, 0, Math.PI, false); ctx.closePath();
        ctx.fillStyle = mediumColors[currentMediumName] || '#B0E0E6';
        ctx.fill(); ctx.strokeStyle = 'black'; ctx.stroke();
        ctx.beginPath(); ctx.moveTo(entryPointX - blockRadius, boundaryY); ctx.lineTo(entryPointX + blockRadius, boundaryY); ctx.lineWidth = 1; ctx.stroke();
        ctx.beginPath(); ctx.setLineDash([5, 5]); ctx.moveTo(entryPointX, 0); ctx.lineTo(entryPointX, height); ctx.strokeStyle = 'grey'; ctx.stroke(); ctx.setLineDash([]);
        const iRad = angleIncidence * Math.PI / 180;
        const sin_r_val = (n1 / n2) * Math.sin(iRad);
        const rRad = (Math.abs(sin_r_val) > 1) ? Math.PI / 2 : Math.asin(sin_r_val);
        const angleRefraction = rRad * 180 / Math.PI;
        const incidentLength = 150;
        const startX_i = entryPointX - incidentLength * Math.sin(iRad), startY_i = boundaryY - incidentLength * Math.cos(iRad);
        ctx.beginPath(); ctx.moveTo(startX_i, startY_i); ctx.lineTo(entryPointX, boundaryY); ctx.strokeStyle = 'red'; ctx.lineWidth = 2; ctx.stroke();
        const midX_i = startX_i + (entryPointX - startX_i) / 2, midY_i = startY_i + (boundaryY - startY_i) / 2;
        ctx.fillStyle = 'red'; drawArrowhead(ctx, startX_i, startY_i, midX_i, midY_i, 8);
        const refractedLength = 150;
        const endX_r = entryPointX + refractedLength * Math.sin(rRad), endY_r = boundaryY + refractedLength * Math.cos(rRad);
        ctx.beginPath(); ctx.moveTo(entryPointX, boundaryY); ctx.lineTo(endX_r, endY_r); ctx.stroke();
        const midX_r = entryPointX + (endX_r - entryPointX) / 2, midY_r = boundaryY + (endY_r - boundaryY) / 2;
        drawArrowhead(ctx, entryPointX, boundaryY, midX_r, midY_r, 8);
        ctx.font = '16px Arial'; ctx.fillStyle = 'black';
        ctx.beginPath(); ctx.arc(entryPointX, boundaryY, 40, -Math.PI / 2, -Math.PI / 2 - iRad, true); ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)'; ctx.stroke();
        ctx.fillText(`i = ${angleIncidence}°`, entryPointX - 60, boundaryY - 20);
        ctx.beginPath(); ctx.arc(entryPointX, boundaryY, 40, Math.PI / 2, Math.PI / 2 - rRad, true); ctx.stroke();
        ctx.fillText(`r = ${angleRefraction.toFixed(1)}°`, entryPointX + 20, boundaryY + 40);
        
        const labelText = capitalize(currentMediumName);
        const labelX = entryPointX + blockRadius + 10, labelY = boundaryY + 40;
        ctx.font = '18px Arial'; ctx.fillText(labelText, labelX, labelY);
        ctx.beginPath();
        const lineY = labelY - 5, lineStartX = entryPointX + blockRadius - 20, lineEndX = labelX - 5;
        ctx.moveTo(lineStartX, lineY); ctx.lineTo(lineEndX, lineY); ctx.strokeStyle = 'black'; ctx.lineWidth = 1; ctx.stroke();
    }
    
    // --- Table & State Management ---
    function initializeTable() {
        dataTableBody.innerHTML = '';
        for (let i = 0; i < 5; i++) {
            const row = document.createElement('tr');
            row.innerHTML = '<td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td class="uncertainty-cell">-</td>';
            dataTableBody.appendChild(row);
        }
    }
    function resetSimulation() { dataPoints = []; updateGraphAndTable(); }
    function fullResetApp() {
        // Reset data points and update table/graph
        resetSimulation();

        // Reset controls to default
        slider.value = 45;
        angleIncidence = 45;
        angleValueSpan.textContent = '45';
        updateSliderBackground(slider);
        
        uncertaintyToggle.checked = false;
        
        // Reset medium selector to Perspex
        mediumButtons.forEach(btn => btn.classList.remove('active'));
        const perspexButton = document.querySelector('.medium-button[data-value="perspex"]');
        if (perspexButton) {
            perspexButton.classList.add('active');
        }
        n2 = refractiveIndices.perspex;
        
        // Update labels and redraw simulation
        updateLabels('perspex');
        drawSimulation();
    }
    function updateLabels(mediumName) {
        const capitalizedName = capitalize(mediumName);
        tableMediumLabel.textContent = `Results Table: ${capitalizedName}`;
        graphMediumLabel.textContent = `Graph of sin i vs. sin r: ${capitalizedName}`;
    }

    // --- Chart.js Plugin for Gradient Helper Lines ---
    const gradientHelperLinePlugin = {
        id: 'gradientHelperLine',
        afterDraw: (chartInstance) => {
            if (chartInstance.gradientPoints) {
                const { ctx } = chartInstance.chart;
                let xScale, yScale;
                for (const scaleId in chartInstance.scales) {
                    if (chartInstance.scales[scaleId].isHorizontal()) {
                        xScale = chartInstance.scales[scaleId];
                    } else {
                        yScale = chartInstance.scales[scaleId];
                    }
                }
                if (!xScale || !yScale) return;

                const { x1, y1, x2, y2 } = chartInstance.gradientPoints;
                const pixelX1 = xScale.getPixelForValue(x1);
                const pixelX2 = xScale.getPixelForValue(x2);
                const pixelY1 = yScale.getPixelForValue(y1);
                const pixelY2 = yScale.getPixelForValue(y2);

                ctx.save();
                ctx.beginPath();
                ctx.setLineDash([5, 5]);
                ctx.strokeStyle = 'green';
                ctx.lineWidth = 2;
                ctx.moveTo(pixelX1, pixelY1);
                ctx.lineTo(pixelX2, pixelY1);
                ctx.lineTo(pixelX2, pixelY2);
                ctx.stroke();
                ctx.restore();
            }
        }
    };

    // --- Graph and Table Update Functions ---
    function updateGraphAndTable() {
        dataTableBody.innerHTML = ''; 
        const isUncertaintyEnabled = uncertaintyToggle.checked;
        
        const chartData = dataPoints.map(p => ({ x: p.sin_r, y: p.sin_i }));
        chart.data.datasets[0].data = chartData;

        dataPoints.forEach(point => {
            const row = document.createElement('tr');
            const r1 = point.r_values[0] ? point.r_values[0].toFixed(1) : '-';
            const r2 = point.r_values[1] ? point.r_values[1].toFixed(1) : '-';
            const r3 = point.r_values[2] ? point.r_values[2].toFixed(1) : '-';
            const r_mean_val = point.r_mean ? point.r_mean.toFixed(1) : '-';
            
            let uncertaintyText = 'N/A';
            if (isUncertaintyEnabled) {
                if (point.r_values.length > 1) {
                    const max_r = Math.max(...point.r_values);
                    const min_r = Math.min(...point.r_values);
                    const uncertainty = (max_r - min_r) / point.r_values.length;
                    uncertaintyText = `±${uncertainty.toFixed(2)}`;
                } else {
                     uncertaintyText = '±0.00';
                }
            }
            
            row.innerHTML = `<td>${point.i.toFixed(1)}</td>
                             <td>${r1}</td>
                             <td>${r2}</td>
                             <td>${r3}</td>
                             <td>${r_mean_val}</td>
                             <td>${point.sin_i.toFixed(3)}</td>
                             <td>${point.sin_r.toFixed(3)}</td>
                             <td class="uncertainty-cell">${uncertaintyText}</td>`;
            dataTableBody.appendChild(row);
        });
        const blankRowsToAdd = Math.max(0, 5 - dataPoints.length);
        for (let i = 0; i < blankRowsToAdd; i++) {
            const row = document.createElement('tr');
            row.innerHTML = '<td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td class="uncertainty-cell">-</td>';
            dataTableBody.appendChild(row);
        }
        
        if (dataPoints.length >= 2) {
            const regressionPoints = dataPoints.map(p => [p.sin_r, p.sin_i]);
            const result = regression.linear(regressionPoints, { precision: 4 });
            const gradient = result.equation[0];
            const intercept = result.equation[1];

            const linePoints = [ { x: 0, y: intercept }, { x: 1.0, y: gradient * 1.0 + intercept } ];
            chart.data.datasets[1].data = linePoints;
            
            const sin_r_values = dataPoints.map(p => p.sin_r);
            const min_sin_r = Math.min(...sin_r_values);
            const max_sin_r = Math.max(...sin_r_values);
            let x1 = Math.ceil(min_sin_r * 10) / 10;
            let x2 = Math.floor(max_sin_r * 10) / 10;
            if (x1 > max_sin_r || x2 < min_sin_r || x1 >= x2) {
                x1 = min_sin_r;
                x2 = max_sin_r;
            }
            const y1 = gradient * x1 + intercept;
            const y2 = gradient * x2 + intercept;
            chart.gradientPoints = { x1, y1, x2, y2 };

            let gradientCalcText = `\\( \\frac{\\Delta \\sin(i)}{\\Delta \\sin(r)} = \\frac{${y2.toFixed(3)} - ${y1.toFixed(3)}}{${x2.toFixed(3)} - ${x1.toFixed(3)}} = ${gradient.toFixed(2)} \\)`;
            gradientDisplay.innerHTML = `Gradient (\\(m\\)): ${gradientCalcText}`;
            
            const currentMediumName = Object.keys(refractiveIndices).find(key => refractiveIndices[key] === n2);
            let finalStatement = `The measured refractive index of ${currentMediumName} is: ${gradient.toFixed(2)}`;

            if (isUncertaintyEnabled && result.r2) {
                const uncertainty = Math.abs(gradient * (1-result.r2) * 0.5);
                finalStatement += ` \\( \\pm \\) ${uncertainty.toFixed(2)}`;
            }
            refractiveIndexDisplay.innerHTML = finalStatement;

        } else {
            chart.data.datasets[1].data = [];
            chart.gradientPoints = null;
            gradientDisplay.innerHTML = `Gradient (\\(m\\)): Not yet calculated.`;
            refractiveIndexDisplay.innerHTML = `The measured refractive index is: N/A`;
        }
        
        chart.update();
        if (window.renderMathInElement) { 
            renderMathInElement(document.body, {
                delimiters: [ {left: '\\(', right: '\\)', display: false}, {left: '$$', right: '$$', display: true} ]
            });
        }
    }

    function initializeGraph() {
        const graphCtx = document.getElementById('resultsGraph').getContext('2d');
        chart = new Chart(graphCtx, {
            type: 'scatter',
            data: { 
                datasets: [ 
                    { 
                        label: 'Data Points', data: [], backgroundColor: 'red', borderColor: 'red', borderWidth: 1
                    }, 
                    { 
                        label: 'Best Fit Line', data: [], borderColor: '#8B0000', borderWidth: 2, fill: false, type: 'line', pointRadius: 0
                    },
                    {
                        label: 'Gradient Calculation',
                        data: [],
                        borderColor: 'green',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        type: 'line'
                    }
                ] 
            },
            options: {
                scales: {
                    xAxes: [{
                        type: 'linear', position: 'bottom',
                        scaleLabel: { display: true, labelString: 'sin(r)' },
                        ticks: { min: 0, max: 1.0 },
                        gridLines: { 
                            color: 'lightgrey', 
                            zeroLineColor: 'black',
                            zeroLineWidth: 2
                        }
                    }],
                    yAxes: [{
                        scaleLabel: { display: true, labelString: 'sin(i)' },
                        ticks: { min: 0, max: 1.0 },
                        gridLines: { 
                            color: 'lightgrey',
                            zeroLineColor: 'black',
                            zeroLineWidth: 2
                        }
                    }]
                }
            },
            plugins: [gradientHelperLinePlugin]
        });
    }

    // --- EVENT LISTENERS ---
    slider.addEventListener('input', (e) => {
        angleIncidence = parseFloat(e.target.value);
        angleValueSpan.textContent = angleIncidence;
        drawSimulation();
        updateSliderBackground(e.target);
    });

    measureButton.addEventListener('click', () => {
        const iDeg_perfect = angleIncidence;
        
        let existingPoint = dataPoints.find(p => p.i === iDeg_perfect);

        if (existingPoint && existingPoint.r_values.length >= 3) {
            alert("You have already taken 3 measurements for this angle. Please choose a different angle.");
            return;
        }

        let rDeg_measured;
        const iRad = iDeg_perfect * Math.PI / 180;
        const sin_r_val = (n1 / n2) * Math.sin(iRad);
        if (Math.abs(sin_r_val) > 1) { 
            alert("Total Internal Reflection occurs. Cannot measure."); 
            return; 
        }
        
        const rDeg_perfect = Math.asin(sin_r_val) * 180 / Math.PI;

        if (uncertaintyToggle.checked) {
            const r_uncertainty = rDeg_perfect * UNCERTAINTY_PERCENTAGE;
            const r_error = (Math.random() * 2 - 1) * r_uncertainty;
            rDeg_measured = rDeg_perfect + r_error;
        } else {
            rDeg_measured = rDeg_perfect;
        }

        if (existingPoint) {
            existingPoint.r_values.push(rDeg_measured);
            const sum_r = existingPoint.r_values.reduce((acc, val) => acc + val, 0);
            existingPoint.r_mean = sum_r / existingPoint.r_values.length;
            existingPoint.sin_r = Math.sin(existingPoint.r_mean * Math.PI / 180);
        } else {
            const newPoint = {
                i: iDeg_perfect,
                r_values: [rDeg_measured],
                r_mean: rDeg_measured,
                sin_i: Math.sin(iDeg_perfect * Math.PI / 180),
                sin_r: Math.sin(rDeg_measured * Math.PI / 180)
            };
            dataPoints.push(newPoint);
        }
        
        dataPoints.sort((a, b) => a.i - b.i);
        updateGraphAndTable();
    });

    const mediumButtons = document.querySelectorAll('.medium-button');

    mediumButtons.forEach(button => {
        button.addEventListener('click', (e) => {
            mediumButtons.forEach(btn => btn.classList.remove('active'));
            const clickedButton = e.currentTarget;
            clickedButton.classList.add('active');

            const mediumValue = clickedButton.dataset.value;
            n2 = refractiveIndices[mediumValue];
            updateLabels(mediumValue);
            resetSimulation();
            drawSimulation();
        });
    });

    uncertaintyToggle.addEventListener('change', (e) => {
        resetSimulation();
    });
    
    const resetButton = document.getElementById('resetButton');
    resetButton.addEventListener('click', fullResetApp);

    if (instructionsDetails && instructionsCard) {
        instructionsDetails.addEventListener('toggle', () => {
            if (instructionsDetails.open) {
                instructionsCard.classList.add('is-open');
            } else {
                instructionsCard.classList.remove('is-open');
            }
        });
    }

    // --- INITIALIZATION ---
    document.addEventListener('DOMContentLoaded', function() {
        const renderMath = () => {
            if (window.renderMathInElement) {
                renderMathInElement(document.body, {
                    delimiters: [ {left: '\\(', right: '\\)', display: false}, {left: '$$', right: '$$', display: true} ]
                });
            }
        };

        initializeGraph();
        initializeTable();
        updateLabels('perspex');
        drawSimulation();
        renderMath();
        updateSliderBackground(document.getElementById('angleSlider'));
    });
</script>
</body>
</html>


